---
title: 交易协议
---


## 1。概述

操作定义智能合约中的原子行为。在更高的层面上，事务定义了在去中心化应用程序中以原子方式执行的操作组。与数据库事务类似，形成区块链交易的一组操作必须按照预定义的顺序一个接一个地成功，否则交易将失败。为了在交易失败时保持交易的原子性和完整性，区块链状态会恢复到与处理交易之前的状态一致的状态。这样可以保证在故障点之前执行的任何操作都不会产生任何副作用。


### 1.1。行动

一个动作可以由之前在区块链上创建的一个或多个参与者授权。操作可以在智能合约中显式创建，也可以由应用程序代码隐式生成。对于任何给定的 `actor:action` pair 最多有一个显式关联的最低权限。如果未设置明确的最低权限，则隐式默认值为 `actor@active`。每个演员都可以独立为给定动作设置其个人最低权限。此外，EOS软件中还设置了复杂但灵活的授权结构，允许参与者代表其他账户推送操作。因此，需要进行进一步的检查，以授权参与者发送操作（请参阅 [3.4.2。权限检查](#342-permission-check)）。

交易涉及两种类型的操作。它们的主要不同之处在于 EOS 软件执行它们的方式：

1.显式操作，存在于已签名的交易中（请参阅 [2.交易实例](#2-transaction-instance)）。
2.隐式（内联）操作，这些操作是作为处理事务的副作用而创建的。

隐式（内联）操作也在智能合约代码中定义，就像显式操作一样。关键区别在于，内联操作不包含在通过网络传播并最终包含在区块中的实际交易中；它们是隐含的。


#### 1.1.1。显式操作

顾名思义，常规或显式操作包含在构成交易的实际操作列表中。显式操作被编码为操作实例（请参阅 [3.4.3。操作实例](#343-action-instance)）然后才被推入交易。显式操作还包含与作为事务一部分执行的操作关联的实际有效载荷数据（如果有）。


#### 1.1.2。隐式操作

隐式（内联）操作是由于事务（或其他内联操作，如果是嵌套的）中的显式调用者操作而生成的，该动作需要该隐式操作执行操作才能使调用者操作继续。因此，内联操作的作用范围和权限与调用者操作相同。因此，行内操作可以保证在同一事务中执行。


### 1.2。智能合约

在EOS中，智能合约由一组操作组成，通常按功能分组，以及这些操作所依赖的一组类型定义。因此，行动规定和定义了合同的实际行为。标准EOS合约中实现了多个操作，用于创建账户、生产者投票、代币操作等。应用程序开发人员可以通过在自己的智能合约和应用程序中创建自定义操作来完全扩展、替换或禁用此功能。另一方面，事务通常是在应用程序级别创建的。智能合约对他们来说是不可知的。


#### 1.2.1。实施

EOS 智能合约以 C++ 类的形式实现，其派生自 `eosio::contract`。操作在派生类中以 C++ 方法的形式实现。另一方面，交易是在EOS应用程序中动态生成的（作为交易实例）。EOS 软件处理每个交易实例，并跟踪其从创建、签名、验证和执行的演变过程中的状态。


## 2。交易实例

事务实例由事务标头以及进行实际交易的操作实例和事务扩展的列表组成。交易标头包含根据交易的到期时间评估交易是否包含在区块中的必要信息，该到期时间是在交易被推送执行时计算的。其他字段包括包含交易的区块号、用于防止 “跨链” 或 “跨分叉” 攻击的区块 ID 前缀、CPU 和网络使用量的上限以及延迟交易的秒数（如果适用）。下图描绘了一个事务实例。

![](/images/protocol-xacts_instance.png "Transaction Instance")

操作实例可以由常规操作或上下文无关操作组成。签名是在交易级别创建和验证的。账户和权限按每个操作进行处理。每个操作实例都包含用于验证是否有权根据操作中指定的参与者的权限级别以及智能合约中为该操作定义的实际授权来验证其是否被授权执行的信息（请参阅 [3.4.2。权限检查](#342-permission-check)）。


### 2.1。交易编号

交易实例包含最少的字段集，用于区分一个事务和另一个事务。因此，交易 ID 由交易实例中包含的基本字段的加密哈希组成。因此，事务 ID 完全由封装在事务、事务标头和任何嵌入式事务扩展插件（可选）中的操作列表决定。可以进一步将事务实例专门化为已签名的事务实例或打包的事务实例。


### 2.2。已签名的交易实例

已签名的交易扩展了交易架构的基本内容，以包括签署交易的账户生成的签名。它还包括与交易实例中包含的无上下文操作相关的任何数据（如果有）（请参阅 `signed_transaction` 下面的架构）。除非由适用的参与者签署，否则交易尚未准备好进行执行和验证。

#### signed_transaction 架构

名称 | 类型 | 描述
-|-|-
`expiration` | `time_point_sec` | 交易到期前必须确认的时间
`ref_block_num` | `uint16_t` | 过去 $2^ {16} $ 区块中区块号的低 16 位
`ref_block_prefix` | `uint32_t` | 所指的区块 ID 的低 32 位 ref_block_num'
`max_net_usage_words` | `unsigned_int` | 计费的总网络带宽上限（以 64 位字为单位）
`max_cpu_usage_ms` | `uint8_t` | 计费 CPU 总时间的上限（以毫秒为单位）
`delay_sec` | `unsigned_int` | 延迟交易的秒数
`context_free_actions` | 数组 `action` | 无上下文操作列表（如果有）
`actions` | 数组 `action` | 一览表 [操作实例](#343-action-instance)
`transaction_extensions` | `extensions_type` | 扩展字段以支持其他功能
`signatures` | 数组 `signature_type` | 交易签署后的数字签名
`context_free_data` | 数组 `bytes` | 要发送的无上下文操作数据（如果有）


### 2.3。打包的交易实例

打包交易是一种可选的压缩签名事务，其中包含额外的内部管理字段，以允许解压缩和快速验证。从长远来看，打包的交易可以最大限度地减少空间占用量和区块大小（参见 `packed_transaction` 下面的架构）。打包交易构成了EOS区块链中最通用的交易类型。因此，当交易被推送到区块时，无论是否压缩，它们实际上都是打包的交易。

#### 打包交易架构

名称 | 类型 | 描述
-|-|-
`signatures` | `signature_type` | 交易签署后的数字签名
`compression` | `compression_type` | 使用的压缩方法
`packed_context_free_data` | `bytes` | 压缩的无上下文数据（如果交易已压缩）
`packed_trx` | `bytes` | 压缩交易（如果已压缩）
`unpacked_trx` | `signed_transaction` | 缓存的解压缩事务
`trx_id` | `transaction_id_type` | 交易编号

那个 `unpacked_trx` field 保存构建事务实例后缓存的已解压缩事务。如果已签名的事务先前已压缩，则会将其解压为 `packed_trx` 字段并缓存到 `unpacked_trx`。如果签名的交易是未压缩存储的，则只需将其逐字复制到 `unpacked_trx`。那个 `signatures` 字段允许对交易进行快速签名验证，而无需对交易进行完全解压缩。


## 3。交易生命周期

交易在其生命周期中经历了不同的阶段。首先，在应用程序或EOS客户端（例如cleos）中创建交易，方法是将关联操作推送到事务中。接下来，将交易发送到本地连接的节点，然后由该节点将其中继到活跃的生产节点，以便通过点对点网络进行验证和执行。接下来，活跃的生产者将经过验证的交易与其他交易一起按计划推送到区块。最后，包含交易的区块被推送到所有其他节点进行验证。当绝大多数生产者验证了该区块，并且该区块变得不可逆时，该交易将被永久记录在区块链中，并被认为是不可变的。


### 3.1。创建交易

事务是在应用程序内通过实例化事务对象并将相关操作实例推送到事务实例中的列表中来创建的。操作实例包含有关该操作的接收方账户的实际详细信息、操作名称、必须通过签名和延迟授权交易的参与者和权限级别，以及要发送的实际消息（如果有）（请参阅 `action` 下面的架构）。

#### 操作架构

名称 | 类型 | 描述
-|-|-
`account` | `name` | 已编码的 13 个字符的账户名
`action_name` | `name` | 已编码的 13 个字符的动作名称
`authorization` | 数组 `permission_level` | 一览表 `actor:permission` 授权
`data` | `bytes` | 要发送的操作数据

在应用程序级别创建事务实例后，将安排该事务进行处理。这涉及两个主要步骤：对交易进行签名并将已签名的交易推送到本地节点，以便实际传播和执行交易。这些步骤通常在 EOS 应用程序中执行。


### 3.2。签署交易

交易必须由一组足以满足累积的显式密钥进行签名 `actor:permission` 交易中包含的所有操作中指定的对。这种链接是通过给定权限的权限表完成的。实际的签名密钥是通过在运行应用程序的客户端上查询与签名账户关联的钱包来获得的。

交易签名过程采用三个参数：要签署的交易实例、从中检索应用程序钱包中关联私钥的公钥集以及链 ID。链 ID 标识实际的 EOS 区块链，由其创世状态的哈希值组成，这取决于区块链的初始配置参数。在签署交易之前，EOS软件首先计算交易摘要。摘要值是链 ID、事务实例和上下文无关数据（如果事务有任何上下文无关操作）的 SHA-256 哈希。在计算任何加密哈希值之前，任何实例字段都会被序列化，以避免在哈希计算中包含参考字段（内存地址）。交易摘要计算和签名过程如下所示。

![](/images/protocol-xact_sign.png "Transaction Signing")

计算出交易摘要后，最终使用与签名账户的公钥关联的私钥对摘要进行签名。公私密钥对通常存储在连接到本地节点的本地计算机中。签名过程是在与签名账户关联的钱包管理器中执行的，该账户通常是部署应用程序的同一个用户。钱包管理器提供了一个虚拟安全区域来执行数字签名，因此可以在私钥离开钱包的情况下生成消息签名。签名生成后，最终会将其添加到已签名的交易实例中。


### 3.3。推送交易

交易签名后，将从已签名的事务实例创建一个打包的事务实例，并将其从应用程序推送到本地节点，本地节点反过来又将事务中继到活跃的生成节点进行签名验证、执行和验证。每个收到事务的生成节点都会尝试在其本地上下文中执行和验证该事务，然后再将其中继到下一个生成节点。因此，有效的交易会被中继，而无效的交易会被丢弃。其背后的想法是防止不良行为者通过虚假交易向网络发送垃圾邮件。人们期望在按计划到达活跃的生产者之前，不良交易会被过滤和删除。收到交易后，不假设其有效性。所有交易都会由下一个生产节点再次验证，无论它是否在生成区块。唯一的区别是，生产者按计划尝试通过将其验证的交易推入待处理区块来生成区块，然后将最终的区块推送到自己的本地链并将其中继到其他节点。


### 3.4。验证交易

验证交易的过程是双重的。首先，从交易中提供的签名集中恢复与签署交易的账户关联的公钥。对于EOS中使用的椭圆曲线数字签名算法ECDSA来说，这种恢复在密码学上是可能的。其次，根据已恢复的密钥集检查事务中包含的每个操作的操作授权列表（actor: permission）中指定的每个参与者的公钥，以查看其是否满足。第三，每个人都满意 `actor:permission` 已根据相关的最低权限进行检查 `actor:contract::action` 配对，看看它是否达到或超过该最低值。最后一次检查是在执行任何操作之前在操作级别执行的（请参阅 [3.4.2。权限检查](#342-permission-check)）。


#### 3.4.1。交易上下文

恢复公钥后，将从事务实例创建事务上下文。事务上下文会跟踪操作的跟踪以及每个操作被调度和执行时生成的操作收据。生成的所有状态都保存在事务跟踪实例和操作收据列表中。交易跟踪由操作跟踪列表组成。每个操作跟踪都包含有关已执行操作的信息，其中包括操作收据、操作实例、是否为上下文无关操作以及生成该操作的事务 ID。操作收据将在稍后在交易执行和完成期间生成。


#### 3.4.2。权限检查

由于事务中包含的操作序列必须作为一个整体以原子方式执行，因此EOS软件首先检查每个操作中指定的参与者是否具有执行该操作所需的最低权限。为此，软件会检查每个操作的以下内容：

* 每个动作实例中指定的每个参与者的命名权限。
* 相应的命名权限 `actor:contract::action` 智能合约中指定的配对。

如果至少有一个参与者的命名权限集未达到相应权限要求的最低权限级别 `actor:contract::action` 在智能合约中配对，交易失败。之所以在执行任何操作之前检查操作权限，是因为性能。取消所有操作均未执行的事务比在执行了几个操作后取消事务更有效，但后来由于操作或授权失败而被回退。操作失败期间发生的任何状态更改都必须撤消，以保持数据的完整性。就内存使用和计算资源而言，数据库会话非常昂贵。因此，必须尽可能减少撤消操作。


#### 3.4.3。操作实例

下图描绘了一个操作实例。它由接收者账户、操作名称、参与者及其权限列表以及包含要发送到接收者账户的消息（如果有）的操作数据组成。

![](/images/protocol-xacts_act_instance.png "Action Instance")

#### 3.4.4。权限检查

检查最低权限级别后，将检查与操作实例中每个参与者的权限相匹配的接收者账户权限的权限表。


### 3.5。执行交易

要执行事务，需要启动链式数据库会话并拍摄快照。这允许在任何交易操作失败时回滚对链状态所做的任何更改。相应的事务上下文在执行期间保持事务状态。要执行事务，将调度与相应事务实例关联的每个操作以供执行。先调度无上下文操作（如果有），然后调度常规操作。


#### 3.5.1。应用上下文

为了准备执行操作，将在本地为每个操作创建一个应用上下文实例。顾名思义，应用上下文包含对应用操作所需资源的引用，例如链控制器的实例（请参阅 [网络对等协议：2.2。链条控制器](03_network-peer-protocol.md#22-chain-controller))、保存状态的链式数据库、运行事务的事务上下文、实际操作实例以及操作的接收者账户。


#### 3.5.2。动作跟踪

为了准备执行每个操作，需要初始化操作接收和操作跟踪实例。首先，计算操作实例本身的哈希值并将其存储在操作收据中。接下来，使用有关待处理区块的统计信息来初始化操作跟踪，包括操作的交易将被推送到该区块中。因此，动作跟踪允许将操作追踪到实际的区块和交易，其中包括该操作，包括产生区块的实际节点。最后，通过将处理程序名称、接收者账户和参与者账户与生成节点内链控制器维护的动作处理程序列表进行匹配来定位动作处理程序。加载系统合约和客户端应用程序时，这些操作处理程序将应用于控制器中。处理程序采用接收者账户名、合约名称、操作名称和操作处理器。


#### 3.5.3。动作执行

找到正确的操作处理程序后，就会检查相应的白名单和黑名单。如果节点当前正在生成区块，则根据账户白名单和黑名单（如果有）检查接收方账户。接下来将检查操作黑名单（如果有）。如果接收者账户或操作名称在黑名单中，则该操作将中止。如果收款人账户已经在白名单上，则会跳过黑名单检查。如果所有检查都通过，则最终通过调用相应的操作处理程序来执行操作，将actor帐户传递到 `from` 参数和收款账户在 `to` 参数。


### 3.6。完成交易

在事务中包含的所有操作都执行完毕后，交易进入终结阶段。在此步骤中，将为每个操作生成相应的操作收据。操作收据包含相应操作实例的哈希值、几个用于分析的计数器以及该操作的接收者账户（如果适用）。


#### 3.6.1。交易收据

在为交易生成所有操作收据后，最终会创建交易收据并将其与区块中包含的其他交易收据一起推送到已签名的区块中。交易收据汇总了交易的结果（已执行、未执行、失败、延迟、过期等），包括以微秒为单位的实际计费 CPU 量和使用的总净存储量（请参阅 `transaction_receipt` 下面的架构）。

##### 交易收据架构

名称 | 类型 | 描述
-|-|-
`status` | `uint8_t` | 交易执行尝试的结果
`cpu_usage_us` | `uint32_t` | 已使用的 CPU 总量（以微秒为单位）
`net_usage_words` | `unsigned int` | 以 64 位字数计算的总净使用量
`trx` | `variant` | 持有交易 ID 或打包交易

那个 `status` field 是一种 8 位枚举类型，可以保存以下结果之一：

* `executed` -交易成功，未执行错误处理程序。
* `soft_fail` -事务失败，错误处理成功。
* `hard_fail` -事务失败，错误处理程序失败。
* `delayed` -交易因用户而延迟，以备将来执行。
* `expired` -交易已过期，CPU/NET 已退还给用户。

>ℹ️ 那个 `delayed` 状态仅适用于**延迟的用户交易**，即用户创建的显式交易，这些交易需要延迟才能满足授权（请参阅 [3.6.3。用户交易延迟](#363-delayed-user-transactions) 了解更多信息）。

那个 `trx` 字段保存交易 ID 或打包后的交易本身。实际选择取决于交易类型。延迟事务处理和延迟用户事务处理生成的收据按事务 ID 存储；所有其他类型的收据都存储为打包交易。

#### 3.6.2。延期交易

延迟交易是作为处理区块链的副作用而生成的，因此它们的状态存储在链数据库中，而不是区块中。因此，无需在交易收据中明确包括其内容。为了达成共识，所有同步节点都应意识到延迟交易的形式。智能合约发行的延期交易对智能合约没有任何作用或影响 `delayed` 交易收据的状态字段。

>⚠ **警告：**
>弃用通知
>从 EOS 2.0 开始，延迟交易已过时。

#### 3.6.3。用户交易延迟

延迟的用户事务包含推送到网络时打包的交易（延迟计时器开始时）。但是，与普通交易不同，它们具有 “延迟” 状态，因此可以推迟其执行和验证。稍后，当它们执行/失败/过期（延迟计时器结束时）时，它们仅包含事务 ID。这是因为任何同步节点都将拥有来自先前广播区块的交易内容。


### 3.7。验证交易

交易在其生命周期的不同阶段进行验证和验证：首先是它作为松散交易在点对点网络上传播（参见 [3.4。验证交易](#34-verify-transaction)），然后在区块验证期间，因为区块是在绝大多数区块生产者中确认的，如果将 nodeos 配置为在重播期间完全重新验证交易，则可以在区块链重播期间进行区块重播。默认情况下，在重播期间不会完全重新验证记录的交易，因为假设节点操作员已经建立了对本地区块日志的信任，无论是个人还是通过侧信道，因此它不再被视为拜占庭信息的潜在来源。


#### 3.7.1。验证流程

在验证作为区块一部分的交易时，会在不同级别进行多次验证。在完整区块验证中，将重播区块中记录的所有交易，并将本地计算的 merkle 树根哈希（分别由交易收据数据和操作收据数据生成）与 `transaction_mroot` 和 `action_mroot` 区块标题中的字段。因此，如果记录的交易在区块内被篡改，不仅默克尔树根哈希会导致不匹配，而且交易签名也将无法验证。如果篡改不是由真正的区块生产者进行的，则区块签名也将无法验证（请参阅 [共识协议：5.3。区块验证](01_consensus-protocol.md#53-block-validation)).
