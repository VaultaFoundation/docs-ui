---
title: 共识协议
---

## 1.概述

EOS 区块链是一种高效、确定性的分布式状态机，可以以去中心化的方式运行。区块链跟踪一系列互换块中的交易。每个块都以加密方式提交给同一链上的前一个块。因此，在不破坏连续块的密码检查的情况下修改记录在给定块上的交易是很棘手的。这个简单的事实使区块链交易不可变且安全。

### 1.1。区块生产者

在 EOS 生态系统中，块生产和块验证由称为“块生产者”的特殊节点执行。生产者由 EOS 利益相关者选举产生（见 [4. 生产者投票/调度](#4-producer-votingscheduling)).每个生产者通过 `nodeos` 服务。出于这个原因，在活动时间表上生产块的生产者也称为“活动”或“生产”节点。

### 1.2。需要达成共识

块验证在任何一组分布式节点之间提出了挑战。必须有一个共识模型来在去中心化系统中以容错方式验证这些块。共识是此类分布式节点和用户就区块链当前状态达成一致的方式（参见 [3. EOS共识（DPoS+aBFT）](#3-eosio-consensus-dpos--abft)).

## 2. 共识模型

在去中心化系统中，有多种方法可以在一组分布式各方之间达成共识。大多数共识模型通过一些证据达成一致。最流行的两种是工作证明 (PoW) 和权益证明 (PoS)，尽管存在其他类型的基于证明的方案，例如活动证明（PoW 和 PoS 的混合体）、燃烧证明、证明of Capacity, Proof of Elapsed Time等。其他共识方案也存在，例如Paxos和Raft。本文档主要关注 EOS 共识模型。

### 2.1。工作量证明 (PoW)

区块链中使用的两种最常见的共识模型是工作量证明和权益证明。在工作证明中，矿工节点竞相寻找添加到块头的随机数，这会导致块具有某些所需的属性（通常是块头的加密哈希的最高有效位中的一定数量的零）。通过使找到使块有效的随机数在计算上变得昂贵，攻击者很难创建区块链的替代分支，该分支将被网络的其余部分接受为最佳链。工作量证明的主要缺点是网络的安全性取决于在计算能力上花费大量资源来寻找随机数。

### 2.2。股权证明（PoS）

在股权证明中，拥有最大股权或某些资产百分比的节点具有同等的决策权。换句话说，投票权与持有的股份成正比。一个有趣的变体是委托权益证明 (DPoS)，其中大量参与者或利益相关者选出较少数量的代表，这些代表反过来为他们做出决定。

## 3. EOS 共识（DPoS + aBFT）

EOS 区块链使用委托权益证明 (DPoS) 来选出将被授权在网络中签署有效区块的活跃生产者。然而，这只是 EOS 共识过程的一半。另一半参与确认每个块直到它成为最终（不可逆）的实际过程，这是以异步拜占庭容错（aBFT）方式执行的。因此，EOS共识模型涉及两层：

* 第 1 层 - 原生共识模型 (aBFT)。
* 第 2 层 - 委托权益证明 (DPoS)。

EOS 中使用的实际原生共识模型没有委托/投票、股权甚至代币的概念。 DPoS 层使用这些来生成块生产者的第一个时间表，如果适用，在每个生产者循环之后最多在每个时间表轮次更新集合。这两层在 EOS 软件中在功能上是分开的。

### 3.1。第 1 层：原生共识 (aBFT)

该层最终决定哪些区块在当选的生产者之间接收并同步，最终成为最终区块，并因此永久记录在区块链中。它得到第二层提出的生产者时间表（见 [3.2.第 2 层：委托 PoS](#32-layer-2-delegated-pos-dpos)) 并使用该时间表来确定哪些块由适当的生产者正确签名。对于拜占庭容错，该层使用两阶段块确认过程，当前调度集中三分之二的绝大多数生产者确认每个块两次。第一个确认阶段提出最后一个不可逆块（LIB）。第二阶段确认拟议的 LIB 为最终阶段。此时，该块变得不可逆。该层还用于在每个调度轮开始时通知生产者调度更改（如果有）。

#### 3.1.1。 EOS 算法最终性
EOS 共识模型通过来自选定的一组特殊参与者（活跃生产者）的签名来实现算法最终性（不同于只能在工作量证明模型中实现的概率最终性），这些参与者被安排在一个时间表中以确定哪​​一方被授权在特定时间段签署区块。对此时间表的更改可以由运行在 EOS 区块链上的特权智能合约发起，但任何对时间表发起的更改只有在发起时间表更改的区块通过两个阶段的确认最终确定之后才会生效。确认的每个阶段都由当前预定的活跃生产者集中的绝大多数生产者执行。

### 3.2。第 2 层：委托权益证明 (DPoS)

委托 PoS 层引入了代币、质押、投票/代理、投票衰减、计票、生产者排名和通货膨胀支付的概念。该层还负责根据生产者投票产生的排名生成新的生产者时间表。这发生在大约两分钟（126 秒）的调度轮中，这是块生产者被分配一个时间段来生产和签署块所花费的时间。每个生产者的时隙总共持续 6 秒，这是生产者回合，最多可以生产和签署 12 个区块。 DPoS 层由 WASM 智能合约启用。

#### 3.2.1。利益相关者和代表

活跃生产者的实际选择（生产者时间表）在每一轮时间表中开放投票，它涉及所有行使参与权的 EOS 利益相关者。但实际上，活跃生产者的排名并不经常变化。利益相关者是普通的 EOS 账户持有人，他们投票选出他们偏好的区块生产者代表他们作为 DPoS 代表行事。然而，与常规 DPoS 的一个主要区别是，一旦当选，无论获得的选票排名如何，所有区块生产者都拥有平等的权力。在其他 DPoS 模型中，投票权与每个代表获得的选票数量成正比。

### 3.3。共识过程

EOS共识过程由两部分组成：

* 生产者投票/调度 - 由 DPoS 第 2 层执行
* 块生产/验证 - 由本地共识层 1 执行

这两个过程是独立的，可以并行执行，除了在创建区块链的第一个创世块时启动序列之后的第一轮调度。

## 4. 生产者投票/调度

下一个时间表中包含的活跃生产者的投票由 DPoS 层执行。严格来说，代币持有者必须首先抵押一些代币才能成为利益相关者，从而能够以给定的抵押权进行投票。

### 4.1。投票程序

每个 EOS 利益相关者可以在一次投票行动中投票给最多 30 个区块生产者。然后，当选的前 21 名生产者将作为 DPoS 代表，代表利益相关者生产和签署区块。其余的生产者按照获得的票数顺序放置在备用列表中。投票过程通过将每个生产者获得的票数相加来重复每一轮计划。没有投票的生产者可以保留他们的旧选票，尽管由于选票衰减而贬值。投票的生产者也可以保留他们的旧选票，除了每个选民的最后投票权重的贡献，这将被他们的新投票权重所取代。

#### 4.1.1。投票权重

每个利益相关者的投票权重是作为质押的代币数量和自 EOS 区块时间戳纪元（定义为 2000 年 1 月 1 日）以来经过的时间的函数来计算的。在当前的实施中，投票权重与数量成正比自 2000 年以来，质押的代币和基数 2 与流逝的时间成指数比例。实际权重以每周 $2^{1/52} = 1.013419$ 的速度增加。这意味着对于相同数量的代币，投票权重每周都会变化，并且每年都会翻倍。

#### 4.1.2。投票衰减

增加投票权重会导致每个生产者当前持有的选票贬值。这种选票衰减是有意为之的，其原因有两个：

* 通过允许新选票比旧选票具有更多权重来鼓励参与。
* 让那些积极参与重要治理事务的用户有更多发言权。

### 4.2。制作人日程

在制作人被投票选出下一个时间表后，他们将按制作人姓名的字母顺序简单地排序。这决定了生产顺序。每个生产者在第一个块中收到下一轮计划的建议生产者集，以从即将开始的当前计划轮进行验证。当包含提议时间表的第一个区块被绝大多数生产者加一个视为不可逆转时，提议的时间表将在下一轮时间表中生效。

#### 4.2.1。生产参数

EOS 区块生产计划在当选的生产者之间平均分配。根据以下参数（每个调度轮），生产者计划在每个调度轮生产预期数量的块：

参数 |说明 |默认 |层
-|-|-|-
**P**（生产者）|活跃生产者数量 | 21 | 2个
**Bp**（块/生产者）|每个生产者的连续块数 | 12 | 1个
**Tb**（秒/块） |每个块的生产时间（s：秒）| 0.5 | 1个

重要的是要提到 Bp（每个生产者的连续块数）和 Tb（每个块的生产时间）是第 1 层共识常量。相反，P（活跃生产者的数量）是由 DPoS 层配置的第 2 层常量，由 WASM 合约启用。

可以根据上述参数定义以下变量（每个调度轮）：

变量 |说明 |方程
-|-|-
**B**（块）|区块总数 | Bp（区块/生产者）x P（生产者）
**Tp** (s/生产者) |每个生产者的生产时间 | Tb（s/块）x Bp（块/生产者）
**T** （小号） |总生产时间 | Tp（s/生产者）x P（生产者）

因此，在第 2 层定义的 P 值可以在 EOS 区块链中动态变化。然而，在实践中，N 在战略上设置为 21 个生产者，这意味着需要 15 个生产者才能达到三分之二的绝对多数，再加上一个才能达成共识。

#### 4.2.2。生产默认值

使用当前默认值：P=21 个当选的生产者，Bp=12 个每个生产者创建的块，每 T=0.5 秒产生一个块，当前生产时间如下（每个调度轮）：

变量 |价值
-|-
**Tp**：每个生产者的生产时间 | Tp = 0.5（s/块）x 12（块/生产者）⇒ Tp = 6（s/生产者）
**T**：总生产时间 | T = 6 (s/生产者) x 21 (生产者) ⇒ T = 126 (s)

当给定的生产者在其分配的时间段内未生产出一个块时，就会在区块链中产生一个间隙。

## 5. 区块生命周期

块由活动生产者在其分配的时间段内按计划创建，然后中继到其他生产者节点以进行同步和验证。这个过程从一个生产者到另一个生产者继续进行，直到新的生产者计划在后面的计划轮次中获得批准。当一个有效区块满足共识要求时（见 [3. EOS共识](#3-eosio-consensus-dpos--abft))，该块成为最终块并且被认为是不可逆的。因此，块在其生命周期中经历三个主要阶段：生产、验证和最终确定。每个阶段也经历不同的阶段。

### 5.1。块结构

作为区块链间的序列，区块链中的基本单位是区块。一个区块包含预验证交易的记录和额外的加密开销，例如区块确认所需的哈希和签名、验证期间交易的重新执行、区块链重放、防止重放攻击等（参见 `block` 下面的架构）。

#### 块架构

名称 |类型 |描述
-|-|-
`timestamp` | `block_timestamp_type` |生成此块的预期时间段（以 .000 或 .500 秒结束）
`producer` | `name` |该区块生产者的账户名
`confirmed` | `uint16_t` |当前生产者时间表中该块的生产者确认的先前块数
`previous` | `block_id_type` |上一个区块的区块ID
`transaction_mroot` | `checksum256_type` |包含在区块中的交易收据的默克尔树根哈希
`action_mroot` | `checksum256_type` |块中包含的动作收据的默克尔树根哈希
`schedule_version` | `uint32_t` |自创世以来生产者时间表发生变化的次数
`new_producers` | `producer_schedule_type` |持有新提议的生产者时间表的生产者名称和密钥；如果没有变化则为 null
`header_extensions` | `extensions_type` |扩展块字段以支持其他功能（包含在块 ID 计算中）
`producer_signature` | `signature_type` |创建并签署区块的生产者的数字签名
`transactions` |数组 `transaction_receipt` |区块中包含的有效交易收据列表
`block_extensions` | `extension_type` |扩展块字段以支持其他功能（不包括在块 ID 计算中）
`id` | `block_id_type` |此块ID的UUID（块头和块号的函数）；可用于查询块以进行验证/检索
`block_num` | `uint32_t` |块号（自创世块 0 以来的顺序计数器值）；可用于查询块以进行验证/检索
`ref_block_prefix` | `uint32_t` |块 ID 的低 32 位；用于防止重放攻击

一些区块字段在创建区块时是预先知道的，因此它们是在区块初始化期间添加的。其他的是在区块最终确定期间计算和添加的，例如交易和操作的默克尔根哈希、区块编号和区块 ID、创建和签署区块的生产者的签名等（参见 [网络对等协议： 3.1。区块编号](03_network-peer-protocol.md#31-block-id))

### 5.2。区块生产

在区块生产的每一轮计划中，计划中的生产者必须创建 Bp=12 个连续区块，其中包含尽可能多的已验证交易。当前每个块在 Tb=500 毫秒（0.5 秒）的跨度内生成。为了保证有足够的时间生产每个区块并传输给其他节点进行验证，区块生产时间进一步分为两个可配置参数：

* **最大处理间隔**：将交易推送到块中的时间窗口（当前设置为 200 毫秒）。
* **最小传播时间**：将块传播到其他节点的时间窗口（当前设置为 300 毫秒）。

所有尚未过期或因先前验证失败而被丢弃的松散交易都保存在本地队列中，以用于块包含和与其他节点同步。在块生产期间，计划的交易由生产者按计划应用和验证，如果有效，则在处理间隔内推送到待处理的块。如果交易落在这个窗口之外，它将被取消应用并重新安排以包含在下一个块中。如果当前生产者没有更多可用的区块槽，则交易最终由另一个生产节点（通过对等协议）拾取并推送到另一个区块。最后一个块（来自 Bp 块的生产者轮次）的最大处理间隔略小，以补偿切换到下一个生产者期间的网络延迟。在处理间隔结束时，待处理块中不再允许交易，并且该块在广播给其他块生产者进行验证之前会经过最终确定步骤。

区块在生产过程中会经历不同的阶段：应用、最终确定、签名和提交。

#### 5.2.1。应用块

应用区块本质上是将生产节点接收并验证的交易推送到一个区块中。在内部，此步骤涉及块头和已签名块实例的创建和初始化。签名块实例只是用签名字段扩展块头。该字段最终包含签署该块的生产者的签名。此外，EOS 最近的变化允许包含多个签名，这些签名存储在标头扩展字段中。

#### 5.2.2。完成块

生成的块需要在签名、提交、中继和验证之前完成。在最终确定期间，块头中加密验证所需的任何字段都会被计算并存储在块中。这包括为动作收据列表和推送到块的交易收据列表生成默克尔树根哈希。

#### 5.2.3。标志块

在交易被推入区块并最终确定区块后，该区块已准备好由生产者签名。这涉及从区块头的序列化内容计算签名摘要，其中包括区块中包含的交易收据。在使用生产者的私钥对区块进行签名后，签名摘要将添加到已签名的区块实例中。这样就完成了区块签名。

#### 5.2.4。提交块

区块签名后，提交到本地链。这会将块推送到可逆块数据库（请参阅 [网络对等协议：2.2.3。分叉数据库](03_network-peer-protocol.md#223-fork-database)).这使得该块可用于与其他节点同步以进行验证（请参阅 [网络对等协议](03_network_peer_protocol.md) 有关块同步的更多信息）。

### 5.3。区块验证

区块验证是在 EOS 区块链内达成共识所必需的基本操作。在区块验证期间，生产者从其他节点接收传入的区块并确认每个区块中包含的交易。区块验证是关于在活跃的生产者中达到足够的法定人数以达成一致：

* 区块及其包含的交易的完整性。
* 每个区块内交易的确定性、时间顺序。

当节点收到块时，验证块的第一步开始。此时，对块执行一些安全检查。如果该块没有链接到已知块，或者它与节点已接收和处理的任何块的块 ID 匹配，则该块将被丢弃。如果该块是新的，则将其推送到链控制器进行处理。

#### 5.3.1。推块

当链控制器接收到块时，软件必须确定在本地链中的何处添加块。 fork 数据库，或简称 Fork DB，就是用于此目的。分叉数据库保存所有已接收但尚未最终确定的具有可逆块的分支。为此，执行以下步骤：

1. 将块添加到分叉数据库。
2.如果块被添加到包含当前头块的主分支，应用块（见 [5.2.1.应用块](#521-apply-block));或者
3. 如果块必须添加到不同的分支，则：
    1. 如果该分支现在成为与当前主分支相比的首选分支：将所有块回滚到最近的共同祖先（并回滚过程中的数据库状态），重新应用不同分支中的所有块，添加新的阻止并应用它。该分支现在成为新的主要分支。
    2. 否则：将新块添加到分支数据库中的那个分支，但不做任何其他事情。

为了将块添加到分叉数据库，必须进行一些块验证。必须始终在将区块添加到分叉数据库之前完成区块头验证。如果必须应用区块，则必须对区块内的交易进行一些验证。交易验证的程度取决于 nodeos 配置的验证模式。支持两种块验证模式：完全验证（默认模式）和轻度验证。

#### 5.3.2。全面验证

在完全验证模式下，应用的每个事务都经过完全验证。这包括验证交易签名和检查授权。

#### 5.3.3。光验证

在轻验证模式下，由可信生产者签名的块（可以在每个节点本地配置）可以跳过在完全验证期间完成的一些交易验证。例如，跳过签名验证，并假定所有声明的操作授权都是有效的。

### 5.4。区块终结性

区块终结性是 EOS 共识的最终结果。它是在绝大多数活跃生产者根据共识规则验证区块后实现的（见 [3.1.第 1 层：原生共识 (aBFT)](#31-layer-1-native-consensus-abft)).最终确定的区块将永久记录在区块链中，无法撤销。在这方面，链中的最后一个不可逆块（LIB）指的是最近成为最终的块。因此，从那时起，记录在区块链上的交易将无法逆转、篡改或删除。

#### 5.4.1。最终目标

最终确定的要点是让用户相信在 LIB 块之前和之前应用的交易不能被修改、回滚或删除。 LIB 块还可以用于活动节点快速有效地确定从哪个分支构建，而不管哪个分支最长。这是因为给定的分支在不包含最新的 LIB 的情况下可能会更长，在这种情况下，必须选择具有最新的 LIB 的较短的分支。
