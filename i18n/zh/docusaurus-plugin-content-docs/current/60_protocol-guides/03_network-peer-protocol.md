---
title: 网络对等协议
---


## 1.概述

EOS 区块链上的节点必须能够相互通信，以在对等方之间中继交易、推送区块和同步状态。点对点 (p2p) 协议的一部分 `nodeos` 在每个节点上运行的服务就是为了这个目的。同步状态的能力对于每个块最终在区块链的全局状态内达到最终状态并允许每个节点推进最后一个不可逆块（LIB）至关重要。在这方面，p2p 协议的根本目标是同步块并在节点之间传播事务以达成共识并推进区块链状态。


### 1.1。目标

为了将多个交易添加到一个块中并在指定的 0.5 秒生产时间内完成它们，p2p 协议的设计必须考虑到速度和效率。这两个目标转化为在有效带宽内最大化交易吞吐量并减少网络和操作延迟。实现这一目标的一些策略包括：

* 在一个区块中容纳更多交易以获得更好的规模经济。
* 尽量减少区块和交易之间的冗余信息。
* 允许更有效地广播和同步节点状态。
* 通过数据压缩和二进制编码最大限度地减少负载足迹。

这些策略中的大多数都在 EOS 软件中全部或部分实现。可选的数据压缩是在事务级别实现的。当通过网络发送对象实例和协议消息时，二进制编码由网络序列化程序实现。


## 2.架构

p2p 协议的主要目标是安全高效地同步节点。为了实现这一总体目标，系统将功能委托给四个主要组件：

* **Net Plugin**：定义同步块和在对等点之间转发交易的协议。
* **链控制器**：在节点内调度/管理接收到的块和交易。
* **Net Serializer**：序列化消息、块和交易以进行网络传输。
* **本地链**：保存节点的区块链本地副本，包括可逆块。

上述组件之间的交互如下图所示：

！[](../images/protocol-p2p_system_arch.png "Peer-to-peer Architecture")

最高层是 Net Plugin，它在节点和它的对等点之间交换消息以同步块和事务。典型的消息流如下：

1. 节点 A 通过 Net Plugin 向节点 B 发送消息（参见上图）。
    1. 节点A的NetSerializer将消息打包发送给节点B。
    2. Node B 的 Net Serializer 解压消息并将其转发给它的 Net Plugin。
2. 消息由 Node B 的 Net Plugin 处理，调度适当的动作。
3. Net Plugin 在必要时通过Chain Controller 访问本地链以推送或检索区块。


### 2.1。本地连锁

本地链是节点的区块链本地副本。它由节点接收到的不可逆和可逆块组成，每个块都与前一个块进行加密链接。不可逆块列表包含不可变区块链的实际副本。可逆块列表的长度通常较短，并且在链控制器向其推送块时由分叉数据库管理。本地链如下所示。

！[](../images/protocol-p2p_local_chain.png "Local Chain (before pruning)")

每个节点在接收块和交易并将其状态与其他节点同步时构建自己的区块链本地副本。可逆块是那些收到但尚未最终确定的新块。因此，它们很可能形成源自一个主要共同祖先的分支，即 LIB（最后一个不可逆区块）。与 LIB 不同的其他共同祖先对于可逆块也是可能的。事实上，任何两个兄弟分支总是有一个最近的共同祖先。例如，在上图中，块 52b 是从块 53a 和 53b 开始的与 LIB 不同的分支的最近共同祖先。本地链中的每个活跃分支都有可能成为区块链的一部分。

#### 2.1.1。库块

在一个节点中构造的所有不可逆块都应与来自其他节点的不可逆块匹配，直到每个节点的最后一个不可逆块（LIB）。这就是区块链的分布式特性。最终，随着 LIB 块之后的块达到最终确定性，LIB 块在追上头块 (HB) 时通过其中一个分支向上移动。当 LIB 区块前进时，不可变区块链有效增长。在此过程中，头块可能会根据收到的潜在头块编号及其时间戳多次切换分支，最终用作决胜局。

### 2.2。链控制器

Chain Controller 管理改变本地链状态的区块和交易的基本操作，例如验证和执行交易、推送区块等。Chain Controller 从 Net Plugin 接收命令并在区块或交易上调度适当的操作基于 Net Plugin 收到的网络消息。网络消息在 EOS 节点之间不断交换，因为它们相互通信以同步块和事务的状态。

#### 2.2.1。信号的生产者和消费者

controller中定义的信号的生产者和消费者及其在正常运行、fork、replay时的生命周期如下：

##### pre_accepted_block（携带signed_block_ptr）

- 由。。。生产

|模组 |函数 |条件 |
| --- | --- | --- |
|控制器 |推块 |在块被添加到分叉数据库之前 |
| |重播推送块 |在将重放块添加到分叉数据库之前（仅当重放块不是不可逆的，因为在重放期间不会将不可逆块添加到分叉数据库）|

- 被消耗

|模组 |用法 |
| --- | --- |
|链插件 |检查点验证 |
| |转发数据到 pre_accepted_block_channel |

##### accepted_block_header（携带block_state_ptr）

- 由。。。生产

|模组 |函数 |条件 |
| --- | --- | --- |
|控制器 |推块|在区块被添加到 fork db 之后 |
| |提交块 |区块添加到fork db后（仅当你是出块者时，换句话说，这不适用于从别人那里收到的区块）|
| |重播推送块 |在将重播块添加到 fork db 之后 | （仅当重放的块不是不可逆的，因为不可逆的块在重放期间不会添加到 fork db）|

- 被消耗

|模组 |用法 |
| --- | --- |
|链插件 |将数据转发到 accepted_block_header_channel |

##### accepted_block（携带block_state_ptr）

- 由。。。生产

|模组 |函数 |条件 |
| --- | --- | --- |
|控制器 |提交块 |当区块完成时 |

- 被消耗

|模组 |用法 |
| --- | --- |
|网络插件 |向其他同行广播块 |

##### irreversible_block（携带block_state_ptr）

- 由。。。生产

|模组 |函数 |条件 |
| --- | --- | --- |
|控制器 | log_irreversible |在将其附加到块日志之前和提交 chainbase 数据库之前 |
| |重播推送块 |重放不可逆块时 |

- 被消耗

|模组 |用法 |
| --- | --- |
|控制器 |设置 wasm_interface 的当前库 |
|链插件 |转发数据到 irreversible_block_channel |

##### accepted_transaction（携带transaction_metadata_ptr）

- 由。。。生产

|模组 |函数 |条件 |
| --- | --- | --- |
|控制器 |推送交易 |当事务成功执行时（仅一次，即未应用和重新应用时不会发出信号）|
| | push_scheduled_transaction |当计划的交易成功执行时 |
| | |当预定交易失败时（主观/软/硬）|
| | |预定交易何时到期 |
| | |应用 onerror 之后 |

- 被消耗

|模组 |用法 |
| --- | --- |
|链插件 |将数据转发到 accepted_transaction_channel |

##### applied_transaction (carry std::tuple<const transaction_trace_ptr&, const signed_transaction&>)

- 由。。。生产

|模组 |函数 |条件 |
| --- | --- | --- |
|控制器 |推送交易 |交易执行成功时 |
| | push_scheduled_transaction |当计划的交易成功执行时 |
| | |当预定交易失败时（主观/软/硬）|
| | |预定交易何时到期 |
| | |应用 onerror 之后 |

- 被消耗

|模组 |用法 |
| --- | --- |
|链插件 |将数据转发到 applied_transaction_channel |

##### 坏分配
不曾用过。

#### 2.2.2。信号的生命周期

##### A.输入区块和交易的正常操作

1. 当一笔交易被推送到区块链时（通过RPC或peer广播）
   1.交易执行成功/验证失败-> `accepted_transaction` 由控制器发出
   2. chain_plugin 将对信号做出反应，将 transaction_metadata 转发到 accepted_transaction_channel
2. 预定交易推送到区块链时
   1.交易执行成功/主观失败/软失败/硬失败-> `accepted_transaction` 由控制器发出
   2. chain_plugin 将响应信号将transaction_metadata 转发到accepted_transaction_channel
3.当一个块被推送到区块链时（通过RPC或者peer广播）
   1. 区块添加到fork db之前-> `pre_accepted_block` 将由控制器发出
   2. chain_plugin 将对信号作出反应以进行块验证将 block_state 转发到 accepted_block_header_channel 并使用检查点对其进行验证
   3.区块加入fork db后-> `accepted_block_header` 将由控制器发出
   4. chain_plugin 将响应信号将 block_state 转发到 accepted_block_header_channel
   5. 然后应用区块，此时区块内的所有交易和scheduled_transactions都会被推送。所有与 push_transaction 和 push_scheduled_transaction 相关的信号（参见 A.1 和 A.2）都会被发射。
   6.提交块时-> `accepted_block` 将由控制器发出
   7. net_plugin 将对信号做出反应并将块广播给对等方
   8. 如果一个新区块变得不可逆，将发出与不可逆区块相关的信号（见A.5点）
4. 出块时
   1. 对于你生产的区块，该区块将在提交时添加到fork_db -> `accepted_block_header` 将由控制器发出
   2. chain_plugin 将响应信号将block_state 转发到accepted_block_header_channel 并使用检查点对其进行验证
   3. 紧接着（在提交块期间）-> `accepted_block` 将由控制器发出
   4. net_plugin 将对信号做出反应并将块广播给对等方
   5. 如果一个新区块变得不可逆，将发出与不可逆区块相关的信号（见A.5点）
5. 当区块变得不可逆时
   1. 一旦一个区块被认为是不可逆的 -> `irreversible_block` 将在块被附加到块日志和提交 chainbase 数据库之前由控制器发出
   2. chain_plugin 将响应信号将block_state 转发到irreversible_block_channel 并设置wasm_interface 的lib

##### B. 分叉出现和解析的操作

1. 当出现分叉时，区块链会将所有现有区块弹出到分叉点，然后应用分叉中的所有新区块。
2. 申请新区块时，会推送区块内的所有交易和scheduled_transactions。所有与 push_transaction 和 push_scheduled_transaction 相关的信号（参见 A.1 和 A.2）都会被发射。
3.然后在提交新块时-> `accepted_block` 将由控制器发出
4. net_plugin 将对信号做出反应并将块广播给对等方
5. 如果一个新区块变得不可逆，将发出与不可逆区块相关的信号（见A.5点）

##### C. 正常回放（有或没有回放优化）

1.重放不可逆块时-> `irreversible_block` 将由控制器发出
2. 参考 A.5 看如何 `irreversible_block` 信号被响应
3. 重放可逆区块时，在区块加入fork_db之前-> `pre_accepted_block` 将由控制器发出
4. 重放可逆区块时，区块加入fork db后-> `accepted_block_header` 将由控制器发出
5.重放可逆块时，当块被提交时-> `accepted_block` 将由控制器发出
6. 参考 A.3 看看如何 `pre_accepted_block`, `accepted_block_header` 和 `accepted_block` 信号被响应

#### 2.2.3。分叉数据库

分叉数据库（Fork DB）为 Chain Controller 提供了一个内部接口，用于对节点的本地链进行操作。当从其他节点接收到新块时，链控制器将这些块推送到 Fork DB。然后每个块都以加密方式链接到前一个块。由于之前的区块可能不止一个，因此该过程可能会产生称为迷你分叉的临时分支。因此，Fork DB 服务于三个主要目的：

* 解决推送块（新头块）将从哪个分支构建。
* 推进头块、根块和 LIB 块。
* 修剪无效分支并清除孤立块。

本质上，Fork DB 包含一个节点内的所有候选块分支，这些分支可能成为继续增长区块链的实际分支。根块始终标记可逆块树的开始，并将匹配 LIB 块，除非 LIB 前进，在这种情况下根块必须赶上。 LIB 块在通过 Fork DB 中的新块前进时的计算将最终决定选择哪个分支。随着 LIB 块的前进，根块会追上新的 LIB，并且其祖先节点位于 LIB 后面的任何候选分支都会被修剪。这在下面描述。

！[](../images/protocol-p2p_local_chain_prunning.png "Local Chain (after pruning)")

在上图中，在 LIB 从节点 51 前进到块 52c，然后是 53c 之后，从块 52b 开始的分支被修剪（块 52b、53a、53b 无效）。当 LIB 移动通过可逆块时，它们从 Fork DB 移动到本地链，因为它们现在成为不可变区块链的一部分。最后，块 54d 保留在 Fork DB 中，因为可能仍会从它构建新块。


### 2.3。网络插件

Net 插件定义了 EOS 节点之间实际的点对点通信消息。 Net Plugin 的主要目标是根据请求同步有效块并始终转发有效交易。为此，Net 插件将功能委托给以下组件：

* **同步管理器**：维护节点相对于其对等节点的块同步状态。
* **Dispatch Manager**：维护节点发送的区块和交易列表。
* **连接列表**：节点当前连接到的活动对等点列表。
* **Message Handler**：将协议消息分派给相应的处理程序。 （看 [4.2.协议消息](#42-protocol-messages)).


#### 2.3.1。同步管理器

同步管理器实现了在节点与其对等方之间同步块状态的功能。它处理每个对等方发送的消息，并根据节点的 LIB 或头块相对于该对等方的状态执行块的实际同步。在任何时候，节点都可以处于以下任何同步状态：

* **LIB Catch-Up**：节点即将与另一个节点的 LIB 块同步。
* **Head Catch-Up**：节点即将与另一个节点的 HEAD 块同步。
* **同步**：LIB 和 HEAD 块都与其他对等方同步。

如果节点的 LIB 或头块落后，节点将生成同步请求消息以从连接的对等方检索丢失的块。类似地，如果连接的对等方的 LIB 或头块落后，节点将发送通知消息以通知节点它需要与哪些块同步。有关同步模式的更多信息，请参阅 [三、操作模式](#3-operation-modes).


#### 2.3.2。调度经理

调度管理器维护节点接收到的块和松散交易的状态。状态包含识别块或交易的基本信息，并在块状态和交易状态的两个索引列表中维护：

* **块状态列表**：节点管理的块状态列表，用于接收到的所有块。
* **交易状态列表**：节点管理的所有交易的交易状态列表。

这使得可以非常快速地定位哪个节点具有给定的块或事务。


##### 2.3.2.1。块状态

块状态标识块及其来自的对等方。它本质上是瞬态的，因此仅在节点处于活动状态时才有效。块状态包含以下字段：

块状态字段 |描述
-|-
`id` | 256 位块标识符。块内容和块号的函数。
`block_num` | 32 位无符号计数器值，自创世以来按顺序标识块。
`connection_id` | 32 位无符号整数，标识块来自的连接对等方。
`have_block` |布尔值，指示节点是否已接收到实际块。

块状态列表按块 ID、块编号和连接 ID 进行索引，以便更快地查找。这允许在给定一个或多个索引属性的情况下查询任何块的列表。


##### 2.3.2.2。交易状态

事务状态标识松散事务及其来源的对等方。它本质上也是瞬态的，因此仅在节点处于活动状态时才有效。交易状态包含以下字段：

交易状态字段 |描述
-|-
`id` |交易实例的 256 位哈希，用作交易标识符。
`expires` |自 EOS 块时间戳纪元（2000 年 1 月 1 日）以来的到期时间。
`block_num` |当前头块号。当 LIB 赶上它时，交易下降。
`connection_id` | 32 位整数，标识交易来自的连接对等方。

这 `block_num` 收到交易时存储节点的头块号。它用作备份机制，当 LIB 块号赶上头块号时丢弃交易，而不管是否过期。

交易状态列表由交易 ID、过期时间、块号和连接 ID 索引，以便更快地查找。这允许在给定一个或多个索引属性的情况下查询列表中的任何事务。


##### 2.3.2.3。状态回收

随着 LIB 块的推进（见 [3.3.1. LIB 追赶模式](#331-lib-catch-up-mode))，新 LIB 块之前的所有块都被认为是最终确定的，因此它们的状态从本地块状态列表中删除，包括节点维护的连接列表中每个对等体拥有的块状态列表。同样，交易状态根据到期时间从交易列表中删除。因此，在交易到期后，其状态将从所有交易状态列表中删除。

区块状态和交易状态的列表具有轻量级和高循环的特点，因此它们被保存在内存中以便更快地访问。节点接收到的块和交易的实际内容分别临时存储在分叉数据库和各种传入队列中，分别用于已申请和未申请的交易。


#### 2.3.3。连接列表

连接列表包含每个对等点的连接状态。它保留有关 p2p 协议版本的信息，该节点知道的来自对等方的块和事务的状态，它当前是否正在与该对等方同步，发送和接收的最后一次握手消息，对等方是否已向该对等方请求信息节点、套接字状态、节点ID等。连接状态包括以下相关字段：

* **Info requested**：peer是否向节点请求了信息。
* **套接字状态**：指向保存 TCP 连接状态的套接字结构的指针。
* **Node ID**：实际的节点 ID，用于区分 peer 节点与其他 peer 节点。
* **Last Handshake Received**：从对等端接收到的最后一次握手消息实例。
* **Last Handshake Sent**：发送给对等方的最后一次握手消息实例。
* **Handshake Sent Count**：发送给对端的握手消息数。
* **正在同步**：节点是否正在与对等方同步。
* **Protocol Version**：peer的Ne​​t Plugin实现的内部协议版本。

块状态由以下字段组成：

* **区块 ID**：区块序列化内容的哈希值。
* **块号**：自创世以来的实际块号。

交易状态由以下字段组成：

* **交易ID**：交易序列化内容的哈希值。
* **区块号**：交易所在的实际区块号。
* **过期时间**：交易过期的时间，以秒为单位。


### 2.4。网络序列化程序

Net Serializer 有两个主要角色：

* 序列化需要通过网络传输的对象和消息。
* 序列化需要加密散列的对象和消息。

在第一种情况下，每个序列化的对象或消息需要在另一端从网络接收后进行反序列化以进行进一步处理。在后一种情况下，需要对对象实例中的特定字段进行序列化，以生成其内容的加密哈希值。大多数为给定对象类型（操作、事务、块等）生成的 ID 都包含来自对象实例的相关字段的加密哈希。


## 3. 操作模式

从操作的角度来看，一个节点相对于一个连接的对等点可以处于三种状态之一：

* **同步模式**：节点与对等方同步，因此不需要来自该对等方的块。
* **LIB 追赶模式**：节点需要区块，因为 LIB 区块落后于该节点的 LIB。
* **HEAD 追赶模式**：节点需要块，因为 HEAD 块位于该节点的 Head 后面。

每个节点的操作模式存储在 nodeos 服务的 Net 插件内的同步管理器上下文中。因此，相对于其连接的对等节点，一个节点总是处于同步模式或追赶模式的某种变体。这允许节点在更新 LIB 和头块以及从其他对等方接收到新的新块时在追赶模式和同步模式之间来回切换。


### 3.1。区块编号

EOS 软件通过比较它们的块 ID 来检查两个块是否匹配或包含相同的内容。区块 ID 是一个函数，它取决于区块头的内容和区块编号（参见 [共识协议：5.1。块结构](01_consensus-protocol.md#51-block-structure)).检查两个块是否相等对于同步节点的本地链与其对等节点的本地链至关重要。为了从块内容生成块 ID，块头被序列化并创建 SHA-256 摘要。最高有效的 32 位被分配了块号，而哈希的最低有效 224 位被保留。请注意，区块头包括交易 merkle 树和动作 merkle 树的根哈希。因此，区块 ID 取决于区块中包含的所有交易以及每个交易中包含的所有操作。


### 3.2。同步模式

在同步模式下，节点的头块追上对等方的头块，这意味着节点在块同步。当节点处于同步模式时，它不会向对等方请求更多块，但会继续执行其他功能：

* **验证交易**，无效则丢弃；如果有效，将它们转发给其他同行。
* **验证块**，如果无效则丢弃它们；如果有效，则根据请求将它们转发给其他同行。

因此，这种模式以带宽换取延迟，由于处理开销较低，对于验证依赖于 TaPoS（作为股权证明的交易）的交易特别有用。

请注意，如果有效且未过期，则始终转发松散交易。另一方面，块只有在有效且对等方明确请求时才会转发。这减少了网络开销。


### 3.3。追赶模式

当一个节点的头块位于对等方的 LIB 或对等方的头块后面时，该节点处于追赶模式。如果需要同步，则分两个顺序步骤执行：

1. 将节点的 LIB 从最近的共同祖先 + 1 同步到对等体的 LIB。
2. 将最近的共同祖先+1 的节点头部同步到对等节点的头部。

因此，首先更新节点的 LIB 块，然后是节点的头块。


#### 3.3.1。 LIB 追赶模式

上面的情况 1，节点的 LIB 块需要赶上对等方的 LIB 块，如下图所示，在同步之前和之后（注意：为清楚起见，已删除不适用的分支）：

！[](../images/protocol-p2p_lib_catchup.png "LIB Catch-Up Mode")

在上图中，节点的本地链通过将最终确定的块 91 和 92（对等方的 LIB）附加到节点的 LIB（块 90）来与对等方的本地链同步。请注意，这会丢弃由块 91n、92n、93n 组成的临时分叉。另请注意，这些节点具有“n”后缀（节点的缩写），表示它们尚未最终确定，因此可能与对等节点不同。这同样适用于对等方的未最终区块；它们以“p”（peer 的缩写）结尾。同步后，请注意 LIB (lib) 和头块 (hb) 在节点上具有相同的块号。


#### 3.3.2。头部追赶模式

在节点的 LIB 块与对等方的同步后，将有新的块被推送到任何一条链。上面的情况 2 涵盖了对等方的链比节点的链长的情况。下图对此进行了描述，该图显示了同步前后节点和对等方的本地链：

！[](../images/protocol-p2p_head_catchup.png "Head Catch-Up Mode")

在上面的情况 1 或 2 中，节点中的同步过程涉及定位第一个公共祖先块，从节点的头块开始，向后遍历链，并以现在同步的 LIB 块结束（参见 [3.3.1. LIB 追赶模式](#331-lib-catch-up-mode)).在最坏的情况下，同步的 LIB 是最近的共同祖先。在上图中，节点的链从头块 94n、93n 等开始遍历，试图匹配对等链中的块 94p、93p 等。第一个匹配的块是最近的共同祖先（图中的块 93n 和 93p）。因此，以下块 94p 和 95p 被检索并附加到节点链中最近的共同祖先之后，现在重新标记为 93n,p（见 [3.3.3.块检索](#333-block-retrieval) 过程）。最后，块 95p 成为节点的头块，由于节点与对等方完全同步，节点切换到同步模式。


#### 3.3.3。块检索

找到共同祖先后，发送同步请求消息以检索节点所需的块，从最近的共同祖先之后的下一个块开始，到对等体的头块结束。

为了有效地利用带宽，必要时，所需的块是从不同的对等点获得的，而不仅仅是一个。根据所需块的数量，通过指定要从给定对等点下载的起始块号和结束块号，以块的形式请求块。该节点使用块状态列表来跟踪每个对等方拥有哪些块，因此此信息用于确定从哪些连接的对等方请求块块。这个过程如下图所示：

！[](../images/protocol-p2p-node-peer-sync.png "Node-peer syncing")

当 LIB 和 head 块都相对于对等体赶上时，同步管理器中的操作模式从赶上模式切换到同步模式。


### 3.4。模式切换

最终，节点及其对等方都从其他对等方接收到新的新块，这些新块又将这些块推送到各自的本地链。这导致每条链上的头部块前进。根据哪个链首先增长，将发生以下操作之一：

* 节点向对等方发送一个追赶请求消息及其头块信息。
* 节点发送一个catch up notice消息来通知peer它需要同步。

在第一种情况下，节点将模式从同步切换到领先追赶模式。在第二种情况下，对端在收到来自节点的通知消息后切换到追赶模式。实际上，同步模式是短暂的。当 EOS 区块链非常繁忙时，节点大部分时间都处于追赶模式，在收到追赶消息后验证交易并同步它们的链。


## 4.协议算法

p2p 协议算法在每个节点上运行，转发经过验证的交易和经过验证的块。从 EOS v2.0 开始，节点还会转发它收到的未验证块的块 ID。一般来说，简化的过程如下：

1. 一个节点向对等节点请求数据或发送控制消息。
2.如果请求可以完成，peer执行请求；重复 1。

数据消息包含区块内容或交易内容。控制消息使节点与其对等方之间的块和事务同步成为可能（请参阅 [协议消息](#42-protocol-messages)).为了允许这种同步，每个节点都必须能够检索有关其自身及其对等方的块和交易状态的信息。


### 4.1。节点/对等状态

在尝试同步状态之前，每个节点都需要知道自己的块和交易的当前状态。它还必须能够查询其他对等点以获得相同的信息。特别是，节点必须能够按需获取以下内容：

* 每个节点都可以查到自己当前有哪些区块和交易。
* 所有节点都可以找出他们的同行有哪些区块和交易。
* 每个节点都可以找出它请求了哪些区块和交易。
* 所有节点都可以查明每个节点何时收到给定的交易。

为了执行这些查询，然后在同步状态时，Net 插件定义了要在节点之间交换的特定通信消息。这些消息在通过 TCP 连接传输和接收时由 Net 插件发送。


### 4.2。协议消息

p2p 协议为对等节点通信定义了以下控制消息：

控制信息 |描述
-|-
`handshake_message` |启动与另一个对等点的连接并发送 LIB/head 状态。
`chain_size_message` |从对等方请求 LIB/head 状态。目前未实施。
`go_away_message` |向连接或已连接的对等方发送断开连接通知。
`time_message` |传输用于对等同步和错误检测的时间戳。
`notice_message` |通知 peer 节点当前拥有哪些块和交易。
`request_message` |通知对等方当前需要哪些块和交易节点。
`sync_request_message` |给定开始/结束块编号的请求对等一系列块。

该协议还定义了以下数据消息，用于在 p2p 网络上的对等点之间交换块的实际内容或松散交易：

资料留言 |描述
-|-
`signed_block` |签名块的序列化内容。
`packed_transaction` |打包事务的序列化内容。


#### 4.2.1。握手消息

握手消息由节点在连接到另一个对等点时发送。连接节点使用它来将其链状态（LIB 编号/ID 和头块编号/ID）传递给对等节点。它也被对等方用来在第一次连接时对节点执行基本验证，例如它是否属于同一区块链，验证字段是否在范围内，检测节点上不一致的块状态，例如它的 LIB 是否位于head block之前等。握手消息由以下字段组成：

留言区 |描述
-|-
`network_version` |用于跟踪协议更新的内部网络插件版本。
`chain_id` |创世状态和配置选项的哈希值。用于识别链。
`node_id` |将对等节点与其他对等节点区分开来的实际节点 ID。
`key` |对等方验证节点的公钥；可能是生产者或对等密钥，或为空。
`time` |自纪元（2000 年 1 月 1 日）以来创建握手消息的时间戳。
`token` |时间戳的 SHA-256 摘要证明节点拥有上述密钥的私钥。
`sig` |在节点使用上述密钥的私钥对其进行签名后，对上述摘要进行签名。
`p2p_address` |节点的IP地址。
`last_irreversible_block_num` |自创世以来 LIB 块的实际块数。
`last_irreversible_block_id` | LIB 块的序列化内容的哈希值。
`head_num` |自创世以来头块的实际块数。
`head_id` |头块的序列化内容的散列。
`os` |节点运行的操作系统。这是自动检测到的。
`agent` |节点提供的名称，用于在其对等节点中标识自己。
`generation` |计数 `handshake_message` 调用；检测第一次调用验证。

如果所有检查都成功，则对等方继续根据 `--allowed-connection` 为该对等方的网络插件指定的设置 `nodeos` 开始：

* **任何**：无需身份验证即可允许连接。
* **生产者**：对等密钥是通过 p2p 协议获得的。
* **指定**：对等密钥通过设置提供。
* **无**：节点不允许连接请求。

对等密钥对应于尝试连接到对等节点的节点的公钥。如果认证成功，接收节点通过发回握手消息确认连接节点，连接节点以与上述相同的方式验证。最后，接收节点检查对等方的头块或自己的头块是否需要同步。这是通过检查头块的状态和连接节点的 LIB 相对于自身的状态来完成的。从这些检查中，接收节点确定哪个链需要同步。


#### 4.2.2。链条尺寸留言

链大小消息是为将来使用而定义的，但目前尚未实现。这个想法是在成功连接到另一个对等点后发送节点链状态的临时状态通知。链大小消息由以下字段组成：

留言区 |描述
-|-
`last_irreversible_block_num` |自创世以来 LIB 块的实际块数。
`last_irreversible_block_id` | LIB 块的序列化内容的哈希值。
`head_num` |自创世以来头块的实际块数。
`head_id` |头块的序列化内容的哈希值。

链大小消息被握手消息取代，握手消息也发送 LIB 和头块的状态，但包含额外信息，因此它是首选。


#### 4.2.3。离开消息

离开消息在关闭连接之前发送给对等方。通常是错误导致节点无法继续执行 p2p 协议。离开消息由以下字段组成：

留言区 |描述
-|-
`reason` |一个错误代码，表示与对等方断开连接的原因。
`node_id` |断开节点的节点 ID；用于重复通知。

目前的原因码定义如下：

* **No reason**：表示实际没有错误；默认值。
* **自我**：节点正在尝试自我连接。
* **重复**：从对等方检测到冗余连接。
* **Wrong chain**：peer的链ID不匹配。
* **Wrong version**：对端的网络版本不匹配。
* **分叉**：对等方的不可逆区块不同
* **Unlinkable**：对等方发送了一个我们无法使用的块
* **Bad transaction**：peer 发送了一个验证失败的交易。
* **验证**：对等方发送了一个验证失败的块。
* **良性其他**：超时等原因。不是致命的，但需要重置。
* **其他致命错误**：捕获所有尚未隔离的致命错误。
* **身份验证**：对等身份验证失败。

对端收到离开消息后，对端也应该关闭连接。


#### 4.2.4。时间消息

时间消息用于节点间同步事件，测量时间间隔，检测网络异常，如重复消息、无效时间戳、节点损坏等。时间消息由以下字段组成：

留言区 |描述
-|-
`org` |起源时间戳；在标记时间间隔的开始时设置。
`rec` |接收时间戳；当消息从网络到达时设置。
`xmt` |传输时间戳；将消息放入发送队列时设置。
`dst` |目的地时间戳；在标记时间间隔结束时设置。


#### 4.2.5。通知留言

发送通知消息以通知对等方节点当前拥有哪些块和松散交易。通知消息由以下字段组成：

留言区 |描述
-|-
`known_trx` |已知交易 ID 节点的排序列表可用。
`known_blocks` |已知块 ID 节点的排序列表可用。

注意消息是轻量级的，因为它们只包含块 ID 和交易 ID，而不是实际的块或交易。


#### 4.2.6。请求消息

发送请求消息是为了通知节点当前需要哪些区块和松散交易。请求消息由以下字段组成：

留言区 |描述
-|-
`req_trx` |节点所需的请求事务 ID 的排序列表。
`req_blocks` |节点所需的请求块 ID 的排序列表。


#### 4.2.7。同步请求消息

同步请求消息向对等方请求一系列块。同步请求消息由以下字段组成：

留言区 |描述
-|-
`start_block` |从对等方接收的块范围的起始块号。
`end_block` |从对等方接收的块范围的结束块号。

收到同步请求消息后，对等方发回指定块编号范围内的实际块。


### 4.3。消息处理器

p2p 协议使用事件驱动模型来处理消息，因此在收到消息时不涉及轮询或循环。在内部，每条消息都放在一个队列中，队列中的下一条消息被分派到相应的消息处理程序进行处理。在高层次上，消息处理程序可以定义如下：

```console
   receiver/read handler:
      if handshake message:
         verify that peer's network protocol is valid
         if node's LIB < peer's LIB:
            sync LIB with peer's; continue
         if node's LIB > peer's LIB:
            send LIB catchup notice message; continue
      if notice message:
         update list of blocks/transactions known by remote peer
      if trx message:
         insert into global state as unvalidated
         validate transaction; drop if invalid, forward if valid
      else
         close the connection
```


### 4.4。发送队列

协议消息被放置在缓冲队列中并发送到适当的连接点。在更高级别，节点以循环方式对每个连接的对等方执行以下操作：

```console
   send/write loop:
      if peer knows the LIB:
         if peer does not know we have a block or transaction:
            next iteration
         if peer does not know about a block:
            send transactions for block that peer does not know
            next iteration 
         if peer does not know about transactions:
            sends oldest transactions unknown to remote peer
            next iteration
         wait for new validated block, transaction, or peer signal
      else:
         assume peer is in catchup mode (operating on request/response)
         wait for notice of sync from the read loop
```


## 5.协议改进

p2p 协议的任何软件更新还必须在所有节点上逐步且一致地扩展。这转化为安装更新，以减少操作停机时间并可能将其完全最小化，同时在可能的情况下以向后兼容的方式部署新功能。另一方面，可以通过采取最小化消息足迹的措施来增加数据吞吐量，例如使用协议消息的数据压缩和二进制编码。
