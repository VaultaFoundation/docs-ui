---
title: åˆ›å»º NFT
---

NFT æ˜¯ä¸€ç§**ä¸å¯æ›¿ä»£çš„ä»£å¸**ã€‚è¿™æ„å‘³ç€å®ƒæ˜¯ä¸€ä¸ªç‹¬ç‰¹çš„ä»¤ç‰Œï¼Œä¸èƒ½
ä¸å¦ä¸€ä¸ªä»¤ç‰Œäº’æ¢ã€‚

ä»¥æ”¶è—å“ä¸ºä¾‹ï¼ˆåäººæ‹¥æœ‰çš„é’¢ç¬”ã€æ¯”èµ›è·èƒœçš„çƒç­‰ï¼‰ã€‚è¿™äº›ä¸­çš„æ¯ä¸€ä¸ª
ç‰©å“æ˜¯ç‹¬ä¸€æ— äºŒçš„ï¼Œä¸èƒ½ä¸å…¶ä»–ç‰©å“äº’æ¢ï¼Œå› ä¸ºå®ƒä»¬çš„ä»·å€¼æ˜¯
åœ¨ä»–ä»¬çš„ç‹¬ç‰¹æ€§ã€‚

> ğŸ‘€ **åªæƒ³åˆ›å»ºä¸€ä¸ª NFTï¼Ÿ**
>
> åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†è®¨è®ºåˆ›å»ºéµå¾ªä»¥å¤ªåŠ ERC721 çš„ NFT
> æ ‡å‡†ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ˜ç¡®çš„æ ‡å‡†æ·±å…¥ç ”ç©¶ä¸€äº› EOS å¼€å‘ã€‚
>
> **ä½†æ˜¯**ï¼Œå¦‚æœä½ æƒ³åˆ›å»ºä¸€ä¸ªéµå¾ª [**åŸå­èµ„äº§**](https://github.com/pinknetworkx/atomicassets-contract) æ ‡å‡†å“ªä¸ª
> åœ¨ EOS Network ä¸Šæ¯”è¾ƒå¸¸è§ï¼Œå¯ä»¥è®¿é—® [åŸå­èµ„äº§ NFT åˆ›é€ è€…](https://eos.atomichub.io/creator)
> æ‚¨å¯ä»¥åœ¨å…¶ä¸­è½»æ¾åˆ›å»º NFTï¼Œæ— éœ€éƒ¨ç½²ä»»ä½•ä»£ç å³å¯ç«‹å³åœ¨ AtomicHub å¸‚åœºä¸Šåˆ—å‡ºã€‚

## ä»€ä¹ˆæ˜¯ NFT æ ‡å‡†ï¼Ÿ

NFT æ ‡å‡†æ˜¯æ‰€æœ‰ NFT å¿…é¡»éµå¾ªçš„ä¸€ç»„è§„åˆ™ã€‚è¿™å…è®¸ NFT æˆä¸º
å¯ä¸å…¶ä»– NFT äº’æ“ä½œï¼Œå¹¶é€‚ç”¨äºå¸‚åœºå’Œé’±åŒ…ç­‰åº”ç”¨ç¨‹åº
äº†è§£å¦‚ä½•ä¸ä»–ä»¬äº’åŠ¨ã€‚

## ERC721 æ ‡å‡†æ˜¯ä»€ä¹ˆï¼Ÿ

è¿™ [ERC721æ ‡å‡†](https://eips.ethereum.org/EIPS/eip-721) æ˜¯ç”±ä»¥å¤ªåŠç¤¾åŒºåˆ›å»ºçš„ NFT æ ‡å‡†ã€‚å®ƒ
æ˜¯æœ€å¸¸è§çš„ NFT æ ‡å‡†ï¼Œè¢«ä»¥å¤ªåŠç½‘ç»œä¸Šçš„è®¸å¤š NFT ä½¿ç”¨ã€‚å¦‚æœä½ æœ‰
è§è¿‡ Bored Apeï¼Œå®ƒä»¬æ˜¯ ERC721 NFTã€‚

ï¼[æ— èŠçŒ¿ä¿±ä¹éƒ¨çš„ä¾‹å­](./images/boredapeclub.jpg)

## ä½ çš„å¼€å‘ç¯å¢ƒ

ç¡®ä¿ä½ æœ‰ [æ²™ä¸˜](../../20_smart-contracts/10_getting-started/10_dune-guide.md) å®‰è£…
å¹¶äº†è§£å¦‚ä½•å»ºç«‹åˆåŒã€‚

åœ¨æ¯ä¸€æ­¥ä¹‹åï¼Œä½ åº”è¯¥å°è¯•ç¼–è¯‘ä½ çš„åˆçº¦å¹¶æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•é”™è¯¯ã€‚

## åˆ›å»ºä¸€ä¸ªæ–°åˆçº¦

åˆ›å»ºä¸€ä¸ªæ–°çš„ `nft.cpp` æ–‡ä»¶å¹¶æ·»åŠ ä»¥ä¸‹ä»£ç ï¼š

```cpp
#include <eosio/eosio.hpp>
#include <eosio/asset.hpp>
#include <eosio/singleton.hpp>
using namespace eosio;

CONTRACT nft : public contract {

    public:
    using contract::contract;
    
    // TODO: Add actions
};
```

## åˆ›å»ºåŠ¨ä½œ

å¦‚æœæˆ‘ä»¬çœ‹ä¸€ä¸‹ [ERC721æ ‡å‡†](https://eips.ethereum.org/EIPS/eip-721), æˆ‘ä»¬å¯ä»¥çœ‹åˆ°
æˆ‘ä»¬éœ€è¦é‡‡å–ä¸€äº›è¡ŒåŠ¨ã€‚æ€»çš„æ¥è¯´ï¼Œæ ‡å‡†å¾ˆç®€å•ï¼Œä½†æ˜¯
æœ‰äº›æ¦‚å¿µä¸ä¸€å®šæ˜¯ EOS åŸç”Ÿçš„ã€‚æ¯”å¦‚æ²¡æœ‰æ¦‚å¿µ
çš„ `approvals` åœ¨ EOS ä¸Šï¼Œå› ä¸ºæ‚¨å¯ä»¥å°†ä»£å¸ç›´æ¥å‘é€åˆ°å¦ä¸€ä¸ªå¸æˆ·ï¼ˆé€šè¿‡ `on_notify` äº‹ä»¶ï¼‰ï¼Œä¸åƒä»¥å¤ªåŠã€‚

ä¸ºäº†ä½¿æ ‡å‡†å°½å¯èƒ½æ¥è¿‘åŸå§‹æ ‡å‡†ï¼Œæˆ‘ä»¬å°†å®æ–½
æœ¬æ•™ç¨‹ä¸­çš„é‚£äº›éæœ¬åœ°æ¦‚å¿µã€‚

æˆ‘ä»¬å°†å®æ–½çš„è¡ŒåŠ¨æ˜¯ï¼š

```cpp
    ACTION mint(name to, uint64_t token_id){
    
    }
    
    ACTION transfer(name from, name to, uint64_t token_id, std::string memo){
    
    }
    
    [[eosio::action]] uint64_t balanceof(name owner){
    
    }
    
    [[eosio::action]] name ownerof(uint64_t token_id){
    
    }
    
    ACTION approve(name to, uint64_t token_id){
    
    }
    
    ACTION approveall(name from, name to, bool approved){
    
    }
    
    [[eosio::action]] name getapproved(uint64_t token_id){
    
    }
    
    [[eosio::action]] bool approved4all(name owner, name approved_account){
    
    }
    
    [[eosio::action]] std::string gettokenuri(uint64_t token_id){
    
    }
    
    ACTION setbaseuri(std::string base_uri){
    
    }
```

å°†å®ƒä»¬æ·»åŠ åˆ°æ‚¨çš„åˆåŒä¸­ï¼Œç„¶åè®©æˆ‘ä»¬æ·±å…¥ç ”ç©¶æ¯ä¸ªæ“ä½œå¹¶æŸ¥çœ‹å®ƒä»¬çš„ä½œç”¨ä»¥åŠå®ƒä»¬é‡‡ç”¨çš„å‚æ•°ã€‚

æ‚¨ä¼šæ³¨æ„åˆ°å¸¦æœ‰è¿”å›å€¼çš„æ“ä½œæ ‡æœ‰ `[[eosio::action]]` åè€Œ
çš„ `ACTION`.

> â” **åŠ¨ä½œå®**
>
> `ACTION` æ˜¯ä¸€ç§å«åš `MACRO`ï¼Œè¿™æ˜¯ä¸€ç§ç¼–å†™å°†è¢«æ›¿æ¢çš„ä»£ç çš„æ–¹æ³•
> åœ¨ç¼–è¯‘æ—¶ä¸å…¶ä»–ä»£ç ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ `ACTION` å®æ›¿æ¢ä¸ºï¼š
> ```cpp
> [[eosio::action]] void
>
```
> æˆ‘ä»¬ä¸èƒ½ä½¿ç”¨çš„åŸå›  `ACTION` ç”¨äºè¿”å›å€¼çš„æ“ä½œçš„å®æ˜¯å› ä¸º
> å®ƒæ·»åŠ äº† `void` å‡½æ•°çš„å…³é”®å­—ï¼Œè¿™æ„å‘³ç€å®ƒä¸ä¼šè¿”å›ä»»ä½•ä¸œè¥¿ã€‚

## æ·±å…¥ç ”ç©¶åŠ¨ä½œå‚æ•°

å¦‚æœä½ æƒ³è¦æ›´æ·±å…¥çš„è§£é‡Šå‚æ•°å’Œç®€å•çš„è§£é‡Š
æ¯ä¸ªåŠ¨ä½œï¼Œå±•å¼€ä¸‹é¢çš„éƒ¨åˆ†ã€‚

<è¯¦æƒ…>
    <summary>ç‚¹æ­¤æŸ¥çœ‹</summary>

ï¼ƒï¼ƒï¼ƒ è–„è·

è¿™ `mint` action ç”¨äºåˆ›å»ºä¸€ä¸ªæ–°çš„ NFTã€‚

å®ƒéœ€è¦ä¸¤ä¸ªå‚æ•°ï¼š
- **to** - å°†æ‹¥æœ‰ NFT çš„è´¦æˆ·
- **token_id** - NFT çš„ ID

ï¼ƒï¼ƒï¼ƒ è½¬ç§»

è¿™ `transfer` action ç”¨äºå°† NFT ä»ä¸€ä¸ªå¸æˆ·è½¬ç§»åˆ°å¦ä¸€ä¸ªå¸æˆ·ã€‚

å®ƒéœ€è¦å››ä¸ªå‚æ•°ï¼š
- **from** - å½“å‰æ‹¥æœ‰ NFT çš„è´¦æˆ·
- **to** - å°†æ‹¥æœ‰ NFT çš„è´¦æˆ·
- **token_id** - NFT çš„ ID
- **å¤‡å¿˜å½•** - å°†åŒ…å«åœ¨äº¤æ˜“ä¸­çš„å¤‡å¿˜å½•

### ä½™é¢

è¿™ `balanceof` action ç”¨äºè·å–å¸æˆ·ä½™é¢ã€‚

å®ƒéœ€è¦ä¸€ä¸ªå‚æ•°ï¼š
- **owner** - æ‚¨æƒ³è¦è·å–ä½™é¢çš„å¸æˆ·

å®ƒè¿”å›ä¸€ä¸ª `uint64_t` è¿™æ˜¯å¸æˆ·çš„ä½™é¢ã€‚

ï¼ƒï¼ƒï¼ƒ çš„ä¸»äºº

è¿™ `ownerof` action ç”¨äºè·å– NFT çš„æ‰€æœ‰è€…ã€‚

å®ƒéœ€è¦ä¸€ä¸ªå‚æ•°ï¼š
- **token_id** - NFT çš„ ID

å®ƒè¿”å›ä¸€ä¸ª `name` è¿™æ˜¯æ‹¥æœ‰ NFT çš„å¸æˆ·ã€‚

ï¼ƒï¼ƒï¼ƒ æ‰¹å‡†

è¿™ `approve` action ç”¨äºæ‰¹å‡†ä¸€ä¸ªè´¦æˆ·ä»£è¡¨ä½ è½¬è´¦ NFTã€‚

å®ƒéœ€è¦ä¸¤ä¸ªå‚æ•°ï¼š
- **to** - å°†è¢«æ‰¹å‡†è½¬ç§» NFT çš„è´¦æˆ·
- **token_id** - NFT çš„ ID

### å…¨éƒ¨æ‰¹å‡†

è¿™ `approveall` action ç”¨äºæ‰¹å‡†ä¸€ä¸ªè´¦æˆ·ä»£è¡¨ä½ è½¬ç§»ä½ æ‰€æœ‰çš„ NFTã€‚

å®ƒéœ€è¦ä¸‰ä¸ªå‚æ•°ï¼š
- **from** - å½“å‰æ‹¥æœ‰ NFT çš„è´¦æˆ·
- **to** - å°†è¢«æ‰¹å‡†è½¬ç§» NFT çš„è´¦æˆ·
- **å·²æ‰¹å‡†** - ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œç”¨äºç¡®å®šå¸æˆ·æ˜¯å¦å·²è·æ‰¹å‡†

### è·å¾—æ‰¹å‡†

è¿™ `getapproved` action ç”¨äºè·å–è·å‡†ä»£ä¸ºè½¬è´¦ NFT çš„è´¦æˆ·ã€‚

å®ƒéœ€è¦ä¸€ä¸ªå‚æ•°ï¼š
- **token_id** - NFT çš„ ID

å®ƒè¿”å›ä¸€ä¸ª `name` è¿™æ˜¯è¢«æ‰¹å‡†è½¬ç§» NFT çš„å¸æˆ·ã€‚

### IsApprovedForAll

è¿™ `approved4all` action ç”¨äºè·å–ä¸€ä¸ªå¸æˆ·æ˜¯å¦è¢«æ‰¹å‡†ä»£è¡¨ä½ è½¬ç§»æ‰€æœ‰ NFTã€‚

å®ƒéœ€è¦ä¸¤ä¸ªå‚æ•°ï¼š
- **owner** - å½“å‰æ‹¥æœ‰ NFT çš„è´¦æˆ·
- **approved_account** - æ‚¨è¦æ£€æŸ¥æ˜¯å¦å·²æ‰¹å‡†è½¬ç§» NFT çš„å¸æˆ·

å®ƒè¿”å›ä¸€ä¸ª `bool` è¿™æ˜¯ `true` å¦‚æœè¯¥å¸æˆ·è¢«æ‰¹å‡†è½¬ç§» NFTï¼Œä»¥åŠ `false` å¦‚æœä¸æ˜¯ã€‚

### ä»¤ç‰ŒURI

è¿™ `gettokenuri` action ç”¨äºè·å– NFT å…ƒæ•°æ®çš„ URIã€‚

å®ƒéœ€è¦ä¸€ä¸ªå‚æ•°ï¼š
- **token_id** - NFT çš„ ID

å®ƒè¿”å›ä¸€ä¸ª `std::string` è¿™æ˜¯ NFT å…ƒæ•°æ®çš„ URIã€‚

### è®¾ç½®BaseURI

è¿™ `setbaseuri` action ç”¨äºè®¾ç½® NFT å…ƒæ•°æ®çš„åŸºç¡€ URIã€‚

å®ƒéœ€è¦ä¸€ä¸ªå‚æ•°ï¼š
- **base_uri** - NFT å…ƒæ•°æ®çš„åŸºæœ¬ URI
    
</è¯¦æƒ…>


## æ·»åŠ æ•°æ®ç»“æ„

ç°åœ¨æˆ‘ä»¬æœ‰äº†æˆ‘ä»¬çš„åŠ¨ä½œï¼Œæˆ‘ä»¬éœ€è¦æ·»åŠ ä¸€äº›æ•°æ®ç»“æ„æ¥å­˜å‚¨ NFTã€‚

æˆ‘ä»¬å°†ä½¿ç”¨ `singleton` å­˜å‚¨ NFTã€‚

> â” **å•èº«äººå£«**
>
> ä¸€ä¸ª `singleton` æ˜¯ä¸€ä¸ªè¡¨ï¼Œæ¯ä¸ªèŒƒå›´åªèƒ½æœ‰ä¸€è¡Œï¼Œä¸åƒ `multi_index` å“ªä¸ª
> æ¯ä¸ªèŒƒå›´å¯ä»¥æœ‰å¤šè¡Œå¹¶ä½¿ç”¨ `primary_key` æ¥è¯†åˆ«æ¯ä¸€è¡Œã€‚
> å•ä¾‹æ›´æ¥è¿‘ä»¥å¤ªåŠçš„å­˜å‚¨æ¨¡å‹ã€‚

å°†ä»¥ä¸‹ä»£ç æ·»åŠ åˆ°æ‚¨çš„åˆåŒä¸­çš„æ“ä½œä¸Šæ–¹ï¼š

```cpp
    using _owners = singleton<"owners"_n, name>;
    using _balances = singleton<"balances"_n, uint64_t>;
    using _approvals = singleton<"approvals"_n, name>;
    using _approvealls = singleton<"approvealls"_n, name>;
    using _base_uris = singleton<"baseuris"_n, std::string>;
    
    ACTION mint...
```

æˆ‘ä»¬ä¸ºä»¥ä¸‹å†…å®¹åˆ›å»ºäº†å•ä¾‹è¡¨ï¼š
- **_owners** - ä»ä»¤ç‰Œ ID åˆ° NFT æ‰€æœ‰è€…çš„æ˜ å°„
- **_balances** - ä»æ‰€æœ‰è€…åˆ°ä»–ä»¬æ‹¥æœ‰çš„ NFT æ•°é‡çš„æ˜ å°„
- **_approvals** - ä»ä»¤ç‰Œ ID åˆ°æ‰¹å‡†è½¬ç§»è¯¥ NFT çš„å¸æˆ·çš„æ˜ å°„
- **_approvealls** - ä»æ‰€æœ‰è€…åˆ°æ‰¹å‡†è½¬ç§»å…¶æ‰€æœ‰ NFT çš„å¸æˆ·çš„æ˜ å°„
- **_base_uris** - å­˜å‚¨ NFT å…ƒæ•°æ®çš„åŸºæœ¬ URI çš„é…ç½®è¡¨

> â” **è¡¨å‘½å**
>
> `singleton<"<TABLE NAME>"_n, <ROW TYPE>>`
>
> å¦‚æœæˆ‘ä»¬æŸ¥çœ‹å•ä¾‹å®šä¹‰ï¼Œåœ¨åŒå¼•å·å†…æˆ‘ä»¬æœ‰è¡¨åã€‚
> EOS è¡¨ä¸­çš„åç§°ä¹Ÿå¿…é¡»éµå¾ªå¸æˆ·åç§°è§„åˆ™ï¼Œè¿™æ„å‘³ç€å®ƒä»¬å¿…é¡»æ˜¯
> 12 ä¸ªå­—ç¬¦æˆ–æ›´å°‘ä¸”åªèƒ½åŒ…å«å­—ç¬¦ `a-z`, `1-5`ï¼Œ å’Œ `.`.

ç°åœ¨æˆ‘ä»¬å·²ç»åˆ›å»ºäº†å­˜å‚¨ NFT æ•°æ®çš„è¡¨å’Œç»“æ„ï¼Œ
æˆ‘ä»¬å¯ä»¥å¼€å§‹ä¸ºæ¯ä¸ªåŠ¨ä½œå¡«å……é€»è¾‘ã€‚


## æ·»åŠ ä¸€äº›è¾…åŠ©å‡½æ•°

æˆ‘ä»¬éœ€è¦ä¸€äº›è¾…åŠ©å‡½æ•°æ¥ä½¿æˆ‘ä»¬çš„ä»£ç æ›´å…·å¯è¯»æ€§å’Œæ›´å®¹æ˜“
ä½¿ç”¨ã€‚åœ¨è¡¨æ ¼å®šä¹‰ä¸‹æ–¹çš„åˆåŒä¸­æ·»åŠ ä»¥ä¸‹ä»£ç ï¼š

```cpp
    using _base_uris = singleton<"baseuris"_n, std::string>;
    
    // Helper function to get the owner of an NFT
    name get_owner(uint64_t token_id){
        
        // Note that we are using the "token_id" as the "scope" of this table.
        // This lets us use singleton tables like key-value stores, which is similar
        // to how Ethereum contracts store data.
        
        _owners owners(get_self(), token_id);
        return owners.get_or_default(name(""));
    }
    
    // Helper function to get the balance of an account
    uint64_t get_balance(name owner){
        _balances balances(get_self(), owner.value);
        return balances.get_or_default(0);
    }
    
    // Helper function to get the account that is approved to transfer an NFT on your behalf
    name get_approved(uint64_t token_id){
        _approvals approvals(get_self(), token_id);
        return approvals.get_or_default(name(""));
    }
    
    // Helper function to get the account that is approved to transfer all of your NFTs on your behalf
    name get_approved_all(name owner){
      _approvealls approvals(get_self(), owner.value);
      return approvals.get_or_default(name(""));
   }
    
    // Helper function to get the URI of the NFT's metadata
    std::string get_token_uri(uint64_t token_id){
        _base_uris base_uris(get_self(), get_self().value);
        return base_uris.get_or_default("") + "/" + std::to_string(token_id);
    }
```

è¾…åŠ©å‡½æ•°å°†ä½¿ä»æˆ‘ä»¬ä¹‹å‰åˆ›å»ºçš„è¡¨ä¸­è·å–æ•°æ®å˜å¾—æ›´åŠ å®¹æ˜“ã€‚
æˆ‘ä»¬å°†åœ¨æ¥ä¸‹æ¥è¦å®ç°çš„æ“ä½œä¸­ä½¿ç”¨è¿™äº›å‡½æ•°ã€‚

ç‰¹åˆ«æ˜¯ï¼ŒæŸäº›åŠŸèƒ½åœ¨å¤šä¸ªåœ°æ–¹ä½¿ç”¨ï¼Œå› æ­¤æœ‰å¿…è¦
ä¸ºä»–ä»¬åˆ›å»ºä¸€ä¸ªè¾…åŠ©å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œ `get_owner` ä½¿ç”¨å‡½æ•°
åœ¨é‡Œé¢ `mint`, `transfer`ï¼Œ å’Œ `approve` åŠ¨ä½œã€‚å¦‚æœæˆ‘ä»¬æ²¡æœ‰åˆ›å»ºè¾…åŠ©å‡½æ•°
ä¸ºæ­¤ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨æ¯ä¸ªæ“ä½œä¸­ç¼–å†™ç›¸åŒçš„ä»£ç ã€‚

## å¡«å†™åŠ¨ä½œ

æˆ‘ä»¬å°†å®Œæˆæ¯ä¸ªæ“ä½œå¹¶ä¸ºå…¶å®ç°é€»è¾‘ã€‚å¯†åˆ‡å…³æ³¨
æ³¨é‡Šï¼Œå› ä¸ºå®ƒä»¬å°†è§£é‡Šæ¯ä¸€è¡Œä»£ç çš„ä½œç”¨ã€‚

ï¼ƒï¼ƒï¼ƒ è–„è·

è¿™ `mint` action ç”¨äºåˆ›å»ºä¸€ä¸ªæ–°çš„ NFTã€‚

```cpp
    ACTION mint(name to, uint64_t token_id){
        // We only want to mint NFTs if the action is called by the contract owner
        check(has_auth(get_self()), "only contract can mint");
        
        // The account we are minting to must exist
        check(is_account(to), "to account does not exist");
        
        // Get the owner singleton
        _owners owners(get_self(), token_id);
        
        // Check if the NFT already exists
        check(owners.get_or_default().value == 0, "NFT already exists");
        
        // Set the owner of the NFT to the account that called the action
        owners.set(to, get_self());
        
        // Get the balances table
        _balances balances(get_self(), to.value);
        
        // Set the new balances of the account
        balances.set(balances.get_or_default(0) + 1, get_self());
    }
```


ï¼ƒï¼ƒï¼ƒ è½¬ç§»

è¿™ `transfer` action ç”¨äºå°† NFT ä»ä¸€ä¸ªå¸æˆ·è½¬ç§»åˆ°å¦ä¸€ä¸ªå¸æˆ·ã€‚

```cpp
    ACTION transfer(name from, name to, uint64_t token_id, std::string memo){
        // The account we are transferring from must authorize this action
        check(has_auth(from), "from account has not authorized the transfer");
        
        // The account we are transferring to must exist
        check(is_account(to), "to account does not exist");
        
        // The account we are transferring from must be the owner of the NFT
        // or allowed to transfer it through an approval
        bool ownerIsFrom = get_owner(token_id) == from;
        bool fromIsApproved = get_approved(token_id) == from;
        check(ownerIsFrom || fromIsApproved, "from account is not the owner of the NFT or approved to transfer the NFT");       
        
        // Get the owner singleton
        _owners owners(get_self(), token_id);
        
        // Set the owner of the NFT to the "to" account
        owners.set(to, get_self());
        
        // Set the new balance for the "from" account
        _balances balances(get_self(), from.value);
        balances.set(balances.get_or_default(0) - 1, get_self());
        
        // Set the new balance for the "to" account
        _balances balances2(get_self(), to.value);
        balances2.set(balances2.get_or_default(0) + 1, get_self());
        
        // Remove the approval for the "from" account
        _approvals approvals(get_self(), token_id);
        approvals.remove();
        
        // Send the transfer notification
        require_recipient(from);
        require_recipient(to);
    }
```

### ä½™é¢

è¿™ `balanceof` action ç”¨äºè·å–å¸æˆ·ä½™é¢ã€‚

```cpp
    [[eosio::action]] uint64_t balanceof(name owner){
        return get_balance(owner);
    }
```

> âš  **è¿”å›å€¼å’Œå¯ç»„åˆæ€§**
>
> è¿”å›å€¼åªèƒ½ä»åŒºå—é“¾å¤–éƒ¨ä½¿ç”¨ï¼Œç›®å‰ä¸èƒ½ä½¿ç”¨
> åœ¨ EOS ä¸­å®ç°æ™ºèƒ½åˆçº¦çš„å¯ç»„åˆæ€§ã€‚ EOSæ”¯æŒ [**å†…è”åŠ¨ä½œ**](../10_getting-started/40_smart-contract-basics.md#inline-actions) å“ªä¸ªå¯ä»¥ç”¨
> è°ƒç”¨å…¶ä»–æ™ºèƒ½åˆçº¦ï¼Œä½†å®ƒä»¬ä¸èƒ½è¿”å›å€¼ã€‚

ï¼ƒï¼ƒï¼ƒ çš„ä¸»äºº

è¿™ `ownerof` action ç”¨äºè·å– NFT çš„æ‰€æœ‰è€…ã€‚

```cpp
    [[eosio::action]] name ownerof(uint64_t token_id){
        return get_owner(token_id);
    }
```

ï¼ƒï¼ƒï¼ƒ æ‰¹å‡†

è¿™ `approve` action ç”¨äºæ‰¹å‡†ä¸€ä¸ªè´¦æˆ·ä»£è¡¨ä½ è½¬è´¦ NFTã€‚

```cpp
    ACTION approve(name to, uint64_t token_id){
        // get the token owner
        name owner = get_owner(token_id);
        
        // The owner of the NFT must authorize this action
        check(has_auth(owner), "owner has not authorized the approval");
    
        // The account we are approving must exist
        check(is_account(to), "to account does not exist");
        
        // Get the approvals table
        _approvals approvals(get_self(), token_id);
        
        // Set the approval for the NFT
        approvals.set(to, get_self());
    }
```

### å…¨éƒ¨æ‰¹å‡†

è¿™ `approveall` æ“ä½œç”¨äºæ‰¹å‡†ä¸€ä¸ªå¸æˆ·è½¬ç§»æ‚¨çš„æ‰€æœ‰
ä»£è¡¨ä½ çš„ NFTã€‚

```cpp
    ACTION approveall(name from, name to, bool approved){
        // The owner of the NFTs must authorize this action
        check(has_auth(from), "owner has not authorized the approval");
        
        // The account we are approving must exist
        check(is_account(to), "to account does not exist");
        
        // Get the approvals table
        _approvealls approvals(get_self(), from.value);
        
        if(approved){
            // Set the approval for the NFT
            approvals.set(to, get_self());
        } else {
            // Remove the approval for the NFT
            approvals.remove();
        }
    }
```

### è·å¾—æ‰¹å‡†

è¿™ `getapproved` action ç”¨äºè·å–è·å‡†è½¬è´¦çš„è´¦æˆ·
ä»£è¡¨ä½ çš„ NFTã€‚

```cpp
    [[eosio::action]] name getapproved(uint64_t token_id){
        return get_approved(token_id);
    }
```

### æ‰¹å‡†4å…¨éƒ¨

è¿™ `approved4all` action ç”¨äºæ£€æŸ¥å¸æˆ·æ˜¯å¦è¢«æ‰¹å‡†è½¬ç§»
ä»£è¡¨ä½ æ‰€æœ‰çš„ NFTã€‚

```cpp
    [[eosio::action]] bool approved4all(name owner, name approved_account){
      return get_approved_all(owner) == approved_account;
   }
```

> âš  **åŠ¨ä½œåç§°é™åˆ¶**
>
> è´¦æˆ·åä¹Ÿæœ‰å’Œè¡¨åä¸€æ ·çš„é™åˆ¶ï¼Œåªèƒ½åŒ…å«
> äººç‰© `a-z`, `1-5`ï¼Œ å’Œ `.`.å› æ­¤ï¼Œæˆ‘ä»¬ä¸èƒ½ä½¿ç”¨æ ‡å‡† `isApprovedForAll`
> åŠ¨ä½œåç§°ï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨ `approved4all` åè€Œã€‚

### ä»¤ç‰ŒURI

è¿™ `tokenuri` action ç”¨äºè·å– NFT çš„ URIã€‚

```cpp
    [[eosio::action]] std::string tokenuri(uint64_t token_id){
        return get_token_uri(token_id);
    }
```

### è®¾ç½®BaseURI

è¿™ `setbaseuri` action ç”¨äºè®¾ç½® NFT çš„åŸºç¡€ URIã€‚

```cpp
    ACTION setbaseuri(std::string base_uri){
        // The account calling this action must be the contract owner
        require_auth(get_self());
        
        // Get the base URI table
        _base_uris base_uris(get_self(), get_self().value);
        
        // Set the base URI
        base_uris.set(base_uri, get_self());
    }
```



## æŠŠå®ƒä»¬æ”¾åœ¨ä¸€èµ·

ç°åœ¨æˆ‘ä»¬å·²ç»åˆ—å‡ºäº†æ‰€æœ‰çš„åŠ¨ä½œï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå®ƒä»¬æ”¾åœ¨ä¸€èµ· `nft.cpp` æ–‡ä»¶ã€‚

åœ¨æŸ¥çœ‹ä¸‹é¢çš„å®Œæ•´åˆçº¦ä¹‹å‰ï¼Œæ‚¨åº”è¯¥å°è¯•è‡ªå·±æ„å»ºã€éƒ¨ç½²åˆçº¦å¹¶ä¸ä¹‹äº¤äº’ã€‚
é¦–å…ˆä½ éœ€è¦é“¸é€ ä¸€äº› NFT åˆ°ä½ æ§åˆ¶çš„è´¦æˆ·ï¼Œç„¶åä½ å¯ä»¥å°è¯•å°†å®ƒä»¬è½¬ç§»åˆ°å¦ä¸€ä¸ªè´¦æˆ·ã€‚

æ‚¨è¿˜å¯ä»¥é€šè¿‡æ‰¹å‡†å¦ä¸€ä¸ªå¸æˆ·ä»£è¡¨æ‚¨è½¬ç§»æ‚¨çš„ NFT æ¥æµ‹è¯•æ‰¹å‡†æœºåˆ¶ï¼Œ
ç„¶åä½¿ç”¨æ‰¹å‡†çš„å¸æˆ·å°†å®ƒä»¬è½¬ç§»åˆ°å¦ä¸€ä¸ªå¸æˆ·ã€‚

<è¯¦æƒ…>
    <summary>ç‚¹å‡»æ­¤å¤„æŸ¥çœ‹å®Œæ•´åˆåŒ</summary>

```cpp
#include <eosio/eosio.hpp>
#include <eosio/asset.hpp>
#include <eosio/singleton.hpp>
using namespace eosio;

CONTRACT nft : public contract {

   public:
   using contract::contract;

   // Mapping from token ID to owner
   using _owners = singleton<"owners"_n, name>;
   
   // Mapping owner address to token count
   using _balances = singleton<"balances"_n, uint64_t>;
   
   // Mapping from token ID to approved address
   using _approvals = singleton<"approvals"_n, name>;
   
   // Mapping from owner to operator approvals
   using _approvealls = singleton<"approvealls"_n, name>;
   
   // Registering the token URI
   using _base_uris = singleton<"baseuris"_n, std::string>;

   // Helper function to get the owner of an NFT
   name get_owner(uint64_t token_id){
      _owners owners(get_self(), token_id);
      return owners.get_or_default(name(""));
   }
   
   // Helper function to get the balance of an account
   uint64_t get_balance(name owner){
      _balances balances(get_self(), owner.value);
      return balances.get_or_default(0);
   }
   
   // Helper function to get the account that is approved to transfer an NFT on your behalf
   name get_approved(uint64_t token_id){
      _approvals approvals(get_self(), token_id);
      return approvals.get_or_default(name(""));
   }
   
   // Helper function to get the account that is approved to transfer all of your NFTs on your behalf
   name get_approved_all(name owner){
      _approvealls approvals(get_self(), owner.value);
      return approvals.get_or_default(name(""));
   }
   
   // Helper function to get the URI of the NFT's metadata
   std::string get_token_uri(uint64_t token_id){
      _base_uris base_uris(get_self(), get_self().value);
      return base_uris.get_or_default("") + "/" + std::to_string(token_id);
   }
   
   ACTION mint(name to, uint64_t token_id){
      // We only want to mint NFTs if the action is called by the contract owner
      check(has_auth(get_self()), "only contract can mint");

      // The account we are minting to must exist
      check(is_account(to), "to account does not exist");

      // Get the owner singleton
      _owners owners(get_self(), token_id);

      // Check if the NFT already exists
      check(owners.get_or_default().value == 0, "NFT already exists");

      // Set the owner of the NFT to the account that called the action
      owners.set(to, get_self());

      // Get the balances table
      _balances balances(get_self(), to.value);

      // Set the new balances of the account
      balances.set(balances.get_or_default(0) + 1, get_self());
   }
   
   ACTION transfer(name from, name to, uint64_t token_id, std::string memo){
      // The account we are transferring from must authorize this action
      check(has_auth(from), "from account has not authorized the transfer");

      // The account we are transferring to must exist
      check(is_account(to), "to account does not exist");

      // The account we are transferring from must be the owner of the NFT
      // or allowed to transfer it through an approval
      bool ownerIsFrom = get_owner(token_id) == from;
      bool fromIsApproved = get_approved(token_id) == from;
      check(ownerIsFrom || fromIsApproved, "from account is not the owner of the NFT or approved to transfer the NFT");       

      // Get the owner singleton
      _owners owners(get_self(), token_id);

      // Set the owner of the NFT to the "to" account
      owners.set(to, get_self());

      // Set the new balance for the "from" account
      _balances balances(get_self(), from.value);
      balances.set(balances.get_or_default(0) - 1, get_self());

      // Set the new balance for the "to" account
      _balances balances2(get_self(), to.value);
      balances2.set(balances2.get_or_default(0) + 1, get_self());

      // Remove the approval for the "from" account
      _approvals approvals(get_self(), token_id);
      approvals.remove();

      // Send the transfer notification
      require_recipient(from);
      require_recipient(to);
   }
   
   [[eosio::action]] uint64_t balanceof(name owner){
      return get_balance(owner);
   }
   
   [[eosio::action]] name ownerof(uint64_t token_id){
      return get_owner(token_id);
   }
   
   ACTION approve(name to, uint64_t token_id){
      // get the token owner
      name owner = get_owner(token_id);
      
      // The owner of the NFT must authorize this action
      check(has_auth(owner), "owner has not authorized the approval");
   
      // The account we are approving must exist
      check(is_account(to), "to account does not exist");
      
      // Get the approvals table
      _approvals approvals(get_self(), token_id);
      
      // Set the approval for the NFT
      approvals.set(to, get_self());
   }
   
   ACTION approveall(name from, name to, bool approved){
      // The owner of the NFTs must authorize this action
      check(has_auth(from), "owner has not authorized the approval");
      
      // The account we are approving must exist
      check(is_account(to), "to account does not exist");
      
      // Get the approvals table
      _approvealls approvals(get_self(), from.value);
      
      if(approved){
         // Set the approval for the NFT
         approvals.set(to, get_self());
      } else {
         // Remove the approval for the NFT
         approvals.remove();
      }
   }
   
   [[eosio::action]] name getapproved(uint64_t token_id){
      return get_approved(token_id);
   }
   
   [[eosio::action]] bool approved4all(name owner, name approved_account){
      return get_approved_all(owner) == approved_account;
   }
   
   [[eosio::action]] std::string gettokenuri(uint64_t token_id){
      return get_token_uri(token_id);
   }
   
   ACTION setbaseuri(std::string base_uri){
      // The account calling this action must be the contract owner
      require_auth(get_self());
      
      // Get the base URI table
      _base_uris base_uris(get_self(), get_self().value);
      
      // Set the base URI
      base_uris.set(base_uri, get_self());
   }
};
```
</è¯¦æƒ…>

## è¿™æ˜¯å‡ºäºæ•™è‚²ç›®çš„

è¯·è®°ä½ï¼Œå¦‚æœæ‚¨åœ¨ EOS ç½‘ç»œä¸Šéƒ¨ç½²æ­¤åˆçº¦å¹¶é“¸é€ ä»£å¸ï¼Œåˆ™
å°†æ²¡æœ‰æ”¯æŒçš„å¸‚åœºæ¥å‡ºå”®å®ƒä»¬ï¼ˆåœ¨æ’°å†™æœ¬æŒ‡å—æ—¶ï¼‰ã€‚è¿™ä»…ç”¨äºæ•™è‚²ç›®çš„ã€‚

ï¼ƒï¼ƒ æŒ‘æˆ˜

è¿™ä¸ª NFT åˆçº¦æ˜¯æ²¡æœ‰åŠæ³•é”€æ¯ NFT çš„ã€‚æ·»åŠ ä¸€ä¸ª `burn` å…è®¸ä»¤ç‰Œæ‰€æœ‰è€…é”€æ¯è‡ªå·±çš„ NFT çš„æ“ä½œã€‚
