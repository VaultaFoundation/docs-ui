---
title: 변수
---

변수 정의는 모든 프로그래밍 언어의 기본 부분입니다.이 섹션에서는 다음을 살펴보겠습니다.
EOS 스마트 계약에서 정의할 수 있는 다양한 유형의 변수

C++는 광범위한 데이터 유형을 지원합니다.EOS++는 EOS 전용 유형으로 유형 세트를 확장합니다.

## 변수 정의

변수는 C++에서와 같은 방식으로 정의됩니다.

```cpp
function main() {
    // <type> <name> = <value>;
    int a = 5;
}
```


## 기본 유형

C++에 기본 제공되는 기본 유형입니다.이전에 이러한 유형을 사용해 본 적이 있을 수 있습니다.
사용하신 다른 프로그래밍 언어에서

달리 지정하지 않는 한 아래 유형은 에서 가져옵니다. `<eosio/eosio.hpp>` 헤더.

```cpp
#include <eosio/eosio.hpp>
```

### 정수 유형

정수 유형은 정수를 나타내는 데 사용됩니다.부호 (양수 또는 음수) 또는 부호 없음 (양수만) 일 수 있습니다.


| 정수 유형 | 설명 |
|------------------------| --- |
| `bool`                 | 부울 (참/거짓) |
| `int8_t`               | 부호 있는 8비트 정수 |
| `int16_t`              | 부호있는 16비트 정수 |
| `int32_t`              | 부호 있는 32비트 정수 |
| `int64_t`              | 부호있는 64비트 정수 |
| `int128_t`             | 부호 있는 128비트 정수 |
| `uint8_t`              | 부호 없는 8비트 정수 |
| `uint16_t`             | 부호 없는 16비트 정수 |
| `uint32_t`             | 부호 없는 32비트 정수 |
| `uint64_t`             | 부호 없는 64비트 정수 |
| `uint128_t`            | 부호 없는 128비트 정수 |

#### 필수 헤더

```cpp
#include <eosio/varint.hpp>
```

| 정수 유형 | 설명 |
|------------------------| --- |
| `signed_int`           | 가변 길이 부호 있는 32비트 정수 |
| `unsigned_int`         | 가변 길이의 부호 없는 32비트 정수 |


### 부동 소수점 유형

부동 소수점 유형은 십진수를 나타내는 데 사용됩니다.

> ⚠ **경고**
> 
> 부동 소수점 유형은 정확하지 않습니다.통화 값을 저장하는 데 적합하지 않으며 종종
> 다른 유형의 데이터를 저장하는 데에도 문제가 있습니다.특히 취급할 때는 주의해서 사용하십시오.
> 블록체인.

| 플로트 유형 | 설명 |
| --- | --- |
| `float` | 32비트 부동 소수점 숫자 |
| `double` | 64비트 부동 소수점 숫자 |

### 바이트 유형

바이트 유형은 바이너리 데이터/문자열과 같은 원시 바이트 시퀀스를 나타내는 데 사용됩니다.

| 블럽 유형 | 설명 |
| --- | --- |
| `bytes` | 원시 바이트 시퀀스 |
| `string` | 문자열 |

### 시간 유형

시간 유형은 특히 블록과 관련된 시간을 나타내는 데 사용됩니다.

| 시간 유형 | 설명 |
| --- |-------------------------------|
| `time_point` | 마이크로초 단위의 포인트 인 타임 |
| `time_point_sec` | 포인트 인 타임 (초) |
| `block_timestamp_type` | 블록 타임스탬프 |


### 해시 유형

해시 유형은 SHA-256 같은 암호화 해시를 나타내는 데 사용됩니다.

| 체크섬 유형 | 설명 |
| --- | --- |
| `checksum160` | 160비트 체크섬 |
| `checksum256` | 256비트 체크섬 |
| `checksum512` | 512비트 체크섬 |

## 사용자 지정 유형

EOS++에 기본 제공되는 사용자 지정 유형입니다.이러한 유형 중 일부는 EOS 스마트 계약에서 자주 사용하게 될 것입니다.

### 이름 유형

더 `name` type은 계정 이름을 나타내는 데 사용됩니다.64비트 정수이지만 문자열로 표시됩니다.

다양한 시스템 함수에는 매개변수로 이름이 필요합니다.

문자열을 이름으로 바꾸는 세 가지 방법이 있습니다.
- `name{"string"}`
- `name("string")`
- `"string"_n`

얻고 싶다면 `uint64_t` 이름의 값은 다음과 같이 사용할 수 있습니다. `value` 방법.

```cpp
name a = name("hello");
uint64_t b = a.value;
```

### 키 및 서명 유형

더 `public_key` 과 `signature` 유형은 암호화 키와 서명을 나타내는 데 사용되며
또한 EOS++ 전용 유형이기도 합니다.

#### 필수 헤더

```cpp
#include <eosio/crypto.hpp>
```

#### 서명에서 키 복구하기

```cpp
function recover(checksum256 hash, signature sig) {
    public_key recovered_key = recover_key(hash, sig);
}
```

### 에셋 유형

더 `asset` type은 디지털 자산의 수량을 나타내는 데 사용됩니다.기호가 있는 64비트 정수이지만 문자열로 표시됩니다.

오버플로 및 언더 플로우에 강하고 산술 연산을 쉽게 수행하는 다양한 방법이 있습니다.

#### 필수 헤더

```cpp
#include <eosio/asset.hpp>
```

| 자산 유형 | 설명 |
| --- | --- |
| `symbol` | 에셋 심볼 |
| `symbol_code` | 자산 심볼 코드 |
| `asset` | 자산 |

#### 에셋 생성

자산에는 수량과 기호라는 두 부분이 있습니다.수량은 64비트 정수이고 기호는
문자열과 정밀도의 조합입니다.

```cpp
// symbol(<symbol (string)>, <precision (1-18)>)
symbol mySymbol = symbol("TKN", 4);

// asset(<quantity (int64_t)>, <symbol>)
asset myAsset = asset(1'0000, mySymbol);
```

#### 산술 연산 수행

자산에 대한 산술 연산을 쉽게 수행할 수 있습니다.

```cpp
asset a = asset(1'0000, symbol("TKN", 4));
asset b = asset(2'0000, symbol("TKN", 4));

asset c = a + b; // 3'0000 TKN
asset d = a - b; // -1'0000 TKN
asset e = a * 2; // 2'0000 TKN
asset f = a / 2; // 0'5000 TKN
```

> ??**심볼 매칭**
> 
> 심볼이 다른 에셋에 대해 산술 연산을 수행하면 오류가 발생하지만 런타임 중에만 발생합니다.다음을 확인하십시오 
> 항상 동일한 심볼을 가진 자산에 대해 작업을 수행하고 있습니다.

#### 에셋 메서드

를 사용하여 자산을 문자열로 변환할 수 있습니다. `to_string` 방법.

```cpp
std::string result = a.to_string(); // "1.0000 TKN"
```

를 사용하여 자산의 수량과 기호를 얻을 수도 있습니다. `amount` 과 `symbol` 방법.

```cpp
int64_t quantity = a.amount; // 1'0000
symbol sym = a.symbol; // symbol("TKN", 4)
```

자산을 사용할 때는 항상 자산이 유효한지 (금액이 범위 내에 있는지) 확인해야 합니다.

```cpp
bool valid = a.is_valid();
```


#### 심볼 메서드

를 사용하여 기호를 문자열로 변환할 수 있습니다. `to_string` 방법.

```cpp
std::string result = mySymbol.to_string(); // "4,TKN"
```

생으로도 얻을 수 있습니다 `uint64_t` 를 사용한 기호 값 `value` 방법.

```cpp
uint64_t value = mySymbol.value;
```

심볼만 사용할 때는 항상 해당 심볼이 유효한지 확인해야 합니다.**하지만 자산을 사용할 때는 이미 확인합니다. 
심볼 자체 내에서의 유효성 `is_valid` 방법.**

```cpp
bool valid = mySymbol.is_valid();
```


## 구조체

구조체는 복잡한 데이터를 나타내는 데 사용됩니다.클래스와 비슷하지만 더 간단하고 가볍습니다.한 번 생각해 보세요
`JSON` 목적.

EOS++에서 사용할 수 있지만 테이블에 저장하는 경우 다음을 사용해야 합니다. `TABLE` 에서 논의할 키워드입니다. 
[다음 섹션](/docs/03_smart-contracts/04_state-data.md).

```cpp
struct myStruct {
    uint64_t id;
};
```
