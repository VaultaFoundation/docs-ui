---
title: NFT ìƒì„±
---

NFTëŠ” **ëŒ€ì²´ ë¶ˆê°€ëŠ¥í•œ í† í°**ì…ë‹ˆë‹¤.ì¦‰, ì¡´ì¬í•  ìˆ˜ ì—†ëŠ” ê³ ìœ í•œ í† í°ì…ë‹ˆë‹¤.
ë‹¤ë¥¸ í† í°ê³¼ êµí™˜ë˜ì—ˆìŠµë‹ˆë‹¤. 

ìˆ˜ì§‘ìš© ì•„ì´í…œ (ìœ ëª…ì¸ì´ ì†Œìœ í•œ íœ, ê²½ê¸°ì—ì„œ ìš°ìŠ¹í•œ ê³µ ë“±) ì„ ì˜ˆë¡œ ë“¤ì–´ ë³´ê² ìŠµë‹ˆë‹¤.ì´ë“¤ ê°ê°ì€
í•­ëª©ì€ ê³ ìœ í•˜ë©° ê°’ì´ ë‹¤ìŒê³¼ ê°™ê¸° ë•Œë¬¸ì— ë‹¤ë¥¸ í•­ëª©ê³¼ êµí™˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
ê·¸ ìì²´ë¡œ ë§ì´ì£ .

>ğŸ‘€ **ê·¸ëƒ¥ NFTë¥¼ ë§Œë“¤ê³  ì‹¶ìœ¼ì‹ ê°€ìš”?**
> >ì´ íŠœí† ë¦¬ì–¼ì—ì„œëŠ” ì´ë”ë¦¬ì›€ì˜ ERC721 ì¶”ì¢…ì„ ë”°ë¥´ëŠ” NFTë¥¼ ë§Œë“œëŠ” ë°©ë²•ì— ëŒ€í•´ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤.
>í‘œì¤€ì´ë¯€ë¡œ ëª…í™•í•œ í‘œì¤€ì„ ì‚¬ìš©í•˜ì—¬ ì¼ë¶€ EOS ê°œë°œì„ ìì„¸íˆ ì‚´í´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> >**í•˜ì§€ë§Œ**, ë‹¤ìŒ NFTë¥¼ ìƒì„±í•˜ë ¤ëŠ” ê²½ìš° [**ì•„í† ë¯¹ ì—ì…‹**](https://github.com/pinknetworkx/atomicassets-contract) ì–´ë–¤ í‘œì¤€ì¸ì§€
>EOS ë„¤íŠ¸ì›Œí¬ì—ì„œ ë” ì¼ë°˜ì ì´ë©° ë‹¤ìŒì„ ë°©ë¬¸í•˜ì‹­ì‹œì˜¤. [ì•„í† ë¯¹ ì—ì…‹ NFT í¬ë¦¬ì—ì´í„°](https://eos.atomichub.io/creator)
>ì½”ë“œë¥¼ ë°°í¬í•˜ì§€ ì•Šê³ ë„ AtomiChub ë§ˆì¼“í”Œë ˆì´ìŠ¤ì— ì¦‰ì‹œ ë“±ë¡ë˜ëŠ” NFTë¥¼ ì‰½ê²Œ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## NFT í‘œì¤€ì´ë€ ë¬´ì—‡ì…ë‹ˆê¹Œ?

NFT í‘œì¤€ì€ ëª¨ë“  NFTê°€ ë”°ë¼ì•¼ í•˜ëŠ” ì¼ë ¨ì˜ ê·œì¹™ì…ë‹ˆë‹¤.ì´ë¥¼ í†µí•´ NFTëŠ”
ë‹¤ë¥¸ NFT ë° ë§ˆì¼“í”Œë ˆì´ìŠ¤ ë° ì§€ê°‘ê³¼ ê°™ì€ ì• í”Œë¦¬ì¼€ì´ì…˜ê³¼ ìƒí˜¸ ìš´ìš© ê°€ëŠ¥
ê·¸ë“¤ê³¼ ìƒí˜¸ ì‘ìš©í•˜ëŠ” ë°©ë²•ì„ ì´í•´í•˜ì‹­ì‹œì˜¤.

## ERC721 ìŠ¤íƒ ë‹¤ë“œë€ ë¬´ì—‡ì…ë‹ˆê¹Œ?

ë” [ERC721 ìŠ¤íƒ ë‹¤ë“œ](https://eips.ethereum.org/EIPS/eip-721) ì´ë”ë¦¬ì›€ ì»¤ë®¤ë‹ˆí‹°ì—ì„œ ë§Œë“  NFT í‘œì¤€ì…ë‹ˆë‹¤.ê·¸ê²ƒ
ê°€ì¥ ì¼ë°˜ì ì¸ NFT í‘œì¤€ì´ë©° ì´ë”ë¦¬ì›€ ë„¤íŠ¸ì›Œí¬ì˜ ë§ì€ NFTì—ì„œ ì‚¬ìš©ë©ë‹ˆë‹¤.ë§Œì•½ ë‹¹ì‹ ì´
ë³´ì–´ë“œ ì—ì´í”„ëŠ” ë³¸ ì ì´ ì—†ëŠ”ë° ERC721 NFTì…ë‹ˆë‹¤.

![ë³´ì–´ë“œ ì—ì´í”„ í´ëŸ½ ì˜ˆì œ](/images/boredapeclub.jpg)

## ìƒˆ ê³„ì•½ ìƒì„±

ì‹ ê·œ ìƒì„± `nft.cpp` íŒŒì¼ì„ ì‘ì„±í•˜ê³  ë‹¤ìŒ ì½”ë“œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

```cpp
#include <eosio/eosio.hpp>
#include <eosio/asset.hpp>
#include <eosio/singleton.hpp>
using namespace eosio;

CONTRACT nft : public contract {

    public:
    using contract::contract;
    
    // TODO: Add actions
};
```

## ì•¡ì…˜ ë§Œë“¤ê¸°

ìš°ë¦¬ê°€ ë³´ë©´ [ERC721 ìŠ¤íƒ ë‹¤ë“œ](https://eips.ethereum.org/EIPS/eip-721), ìš°ë¦¬ëŠ” ê·¸ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤
êµ¬í˜„í•´ì•¼ í•  ëª‡ ê°€ì§€ ì¡°ì¹˜ê°€ ìˆìŠµë‹ˆë‹¤.ì „ë°˜ì ìœ¼ë¡œ í‘œì¤€ì€ ë§¤ìš° ê°„ë‹¨í•˜ì§€ë§Œ
ì¼ë¶€ ê°œë…ì€ ë°˜ë“œì‹œ EOS ê³ ìœ ì˜ ê°œë…ì€ ì•„ë‹™ë‹ˆë‹¤.ì˜ˆë¥¼ ë“¤ì–´, ê°œë…ì´ ì—†ìŠµë‹ˆë‹¤. 
ì˜ `approvals` EOSì—ì„œ í† í°ì„ ë‹¤ë¥¸ ê³„ì •ìœ¼ë¡œ ì§ì ‘ ë³´ë‚¼ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— (ë¥¼ í†µí•´) `on_notify` ì´ë²¤íŠ¸), ì´ë”ë¦¬ì›€ê³¼ ë‹¬ë¦¬.

í‘œì¤€ì„ ê°€ëŠ¥í•œ í•œ ì›ë³¸ì— ê°€ê¹ê²Œ ìœ ì§€í•˜ê¸° ìœ„í•´ ë‹¤ìŒì„ êµ¬í˜„í•©ë‹ˆë‹¤.
ì´ íŠœí† ë¦¬ì–¼ì˜ ì´ëŸ¬í•œ ë¹„ì›ì–´ì  ê°œë….

ìš°ë¦¬ê°€ ì‹œí–‰í•  ì¡°ì¹˜ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

```cpp
    ACTION mint(name to, uint64_t token_id){
    
    }
    
    ACTION transfer(name from, name to, uint64_t token_id, std::string memo){
    
    }
    
    [[eosio::action]] uint64_t balanceof(name owner){
    
    }
    
    [[eosio::action]] name ownerof(uint64_t token_id){
    
    }
    
    ACTION approve(name to, uint64_t token_id){
    
    }
    
    ACTION approveall(name from, name to, bool approved){
    
    }
    
    [[eosio::action]] name getapproved(uint64_t token_id){
    
    }
    
    [[eosio::action]] bool approved4all(name owner, name approved_account){
    
    }
    
    [[eosio::action]] std::string gettokenuri(uint64_t token_id){
    
    }
    
    ACTION setbaseuri(std::string base_uri){
    
    }
```

ê³„ì•½ì— ì¶”ê°€í•œ ë‹¤ìŒ ê° ì‘ì—…ì„ ìì„¸íˆ ì‚´í´ë³´ê³  ì–´ë–¤ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ”ì§€, ì–´ë–¤ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ”ì§€ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

ë°˜í™˜ ê°’ì´ ìˆëŠ” ì‘ì—…ì€ ë‹¤ìŒê³¼ ê°™ì´ í‘œì‹œë˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. `[[eosio::action]]` ëŒ€ì‹ ì—
ì˜ `ACTION`. 

>â” **ì•¡ì…˜ ë§¤í¬ë¡œ**
> > `ACTION` aë¼ê³  ë¶ˆë¦¬ëŠ” ê²ƒì…ë‹ˆë‹¤. `MACRO`, ëŒ€ì²´ë  ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.
>ì»´íŒŒì¼ ì‹œ ë‹¤ë¥¸ ì½”ë“œì™€ í•¨ê»˜.ì´ ê²½ìš°, `ACTION` ë§¤í¬ë¡œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ëŒ€ì²´ë©ë‹ˆë‹¤.
> ```cpp
> [[eosio::action]] void
>
```
>ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ì´ìœ  `ACTION` ê°’ì„ ë°˜í™˜í•˜ëŠ” ì•¡ì…˜ì— ëŒ€í•œ ë§¤í¬ë¡œëŠ”
>ê·¸ê²ƒì€ ë‹¤ìŒì„ ì¶”ê°€í•©ë‹ˆë‹¤ `void` í•¨ìˆ˜ì˜ í‚¤ì›Œë“œì…ë‹ˆë‹¤. ì¦‰, ì•„ë¬´ ê²ƒë„ ë°˜í™˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

## ì•¡ì…˜ íŒŒë¼ë¯¸í„° íŒŒí—¤ì¹˜ê¸°

ë§¤ê°œ ë³€ìˆ˜ì— ëŒ€í•œ ë” ìì„¸í•œ ì„¤ëª…ê³¼ ê°„ë‹¨í•œ ì„¤ëª…ì„ ì›í•˜ëŠ” ê²½ìš°
ê° ì‘ì—…ì„ ìˆ˜í–‰í•˜ë ¤ë©´ ì•„ë˜ ì„¹ì…˜ì„ í™•ì¥í•˜ì‹­ì‹œì˜¤.

<details>
 <summary>ë³´ë ¤ë©´ ì—¬ê¸°ë¥¼ í´ë¦­í•˜ì‹­ì‹œì˜¤</summary>

### ë¯¼íŠ¸

ë” `mint` ì•¡ì…˜ì€ ìƒˆ NFTë¥¼ ë§Œë“œëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ë‘ ê°œì˜ ë§¤ê°œë³€ìˆ˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.
- `to` - NFTë¥¼ ì†Œìœ í•  ê³„ì •
- `token_id` - NFTì˜ ID

### ì „ì†¡

ë” `transfer` ì•¡ì…˜ì€ í•œ ê³„ì •ì—ì„œ ë‹¤ë¥¸ ê³„ì •ìœ¼ë¡œ NFTë¥¼ ì´ì „í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ë„¤ ê°€ì§€ ë§¤ê°œ ë³€ìˆ˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.
- `from` - í˜„ì¬ NFTë¥¼ ì†Œìœ í•˜ê³  ìˆëŠ” ê³„ì •
- `to` - NFTë¥¼ ì†Œìœ í•  ê³„ì •
- `token_id` - NFTì˜ ID
- `memo` - ê±°ë˜ì— í¬í•¨ë  ë©”ëª¨

## ë°¸ëŸ°ìŠ¤ ì˜¤ë¸Œ

ë” `balanceof` ì•¡ì…˜ì€ ê³„ì • ì”ì•¡ì„ ê°€ì ¸ì˜¤ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ë§¤ê°œ ë³€ìˆ˜ í•˜ë‚˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.
- `owner` - ì”ì•¡ì„ ë°›ê³  ì‹¶ì€ ê³„ì¢Œ

aë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. `uint64_t` ì´ê²ƒì´ ê³„ì¢Œì˜ ì”ì•¡ì…ë‹ˆë‹¤.

## ì†Œìœ ì

ë” `ownerof` ì•¡ì…˜ì€ NFTì˜ ì†Œìœ ìë¥¼ ì–»ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ë§¤ê°œ ë³€ìˆ˜ í•˜ë‚˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.
- `token_id` - NFTì˜ ID

aë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. `name` NFTë¥¼ ì†Œìœ í•œ ê³„ì •ì…ë‹ˆë‹¤.

### ìŠ¹ì¸

ë” `approve` ì•¡ì…˜ì€ ê·€í•˜ë¥¼ ëŒ€ì‹ í•˜ì—¬ NFTë¥¼ ì–‘ë„í•  ê³„ì •ì„ ìŠ¹ì¸í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ë‘ ê°œì˜ ë§¤ê°œë³€ìˆ˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.
- `to` - NFT ì „ì†¡ ìŠ¹ì¸ì„ ë°›ì„ ê³„ì •
- `token_id` - NFTì˜ ID

## ëª¨ë‘ ìŠ¹ì¸

ë” `approveall` ì•¡ì…˜ì€ ê·€í•˜ë¥¼ ëŒ€ì‹ í•˜ì—¬ ëª¨ë“  NFTë¥¼ ì´ì „í•˜ê¸° ìœ„í•´ ê³„ì •ì„ ìŠ¹ì¸í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ì„¸ ê°€ì§€ ë§¤ê°œ ë³€ìˆ˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.
- `from` - í˜„ì¬ NFTë¥¼ ì†Œìœ í•˜ê³  ìˆëŠ” ê³„ì •
- `to` - NFT ì´ì²´ê°€ ìŠ¹ì¸ë  ê³„ì •
- `approved` - ê³„ì • ìŠ¹ì¸ ì—¬ë¶€ë¥¼ ê²°ì •í•˜ëŠ” ë¶€ìš¸

## ìŠ¹ì¸ ë°›ê¸°

ë” `getapproved` ì•¡ì…˜ì€ ê·€í•˜ë¥¼ ëŒ€ì‹ í•˜ì—¬ NFTë¥¼ ì´ì „í•˜ë„ë¡ ìŠ¹ì¸ëœ ê³„ì •ì„ ê°€ì ¸ì˜¤ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ë§¤ê°œ ë³€ìˆ˜ í•˜ë‚˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.
- `token_id` - NFTì˜ ID

aë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. `name` NFTë¥¼ ì „ì†¡í•˜ë„ë¡ ìŠ¹ì¸ëœ ê³„ì •ì…ë‹ˆë‹¤.

## #ì€ ëª¨ë‘ ìŠ¹ì¸ë¨

ë” `approved4all` ì•¡ì…˜ì€ ê³„ì •ì´ ê·€í•˜ë¥¼ ëŒ€ì‹ í•˜ì—¬ ëª¨ë“  NFTë¥¼ ì´ì „í•˜ë„ë¡ ìŠ¹ì¸ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ë‘ ê°œì˜ ë§¤ê°œë³€ìˆ˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.
- `owner` - í˜„ì¬ NFTë¥¼ ì†Œìœ í•˜ê³  ìˆëŠ” ê³„ì •
- `approved_account` - NFT ì´ì „ ìŠ¹ì¸ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ë ¤ëŠ” ê³„ì •

aë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. `bool` ì–´ëŠ ê²ƒì´ `true` ê³„ì •ì´ NFTë¥¼ ì´ì „í•˜ë„ë¡ ìŠ¹ì¸ëœ ê²½ìš°, ê·¸ë¦¬ê³  `false` ê·¸ë ‡ì§€ ì•Šì€ ê²½ìš°.

## í† í°ëˆ„ë¦¬

ë” `gettokenuri` ì‘ì—…ì€ NFT ë©”íƒ€ë°ì´í„°ì˜ URIë¥¼ ê°€ì ¸ì˜¤ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ë§¤ê°œ ë³€ìˆ˜ í•˜ë‚˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.
- `token_id` - NFTì˜ ID

aë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. `std::string` NFT ë©”íƒ€ë°ì´í„°ì˜ URIì…ë‹ˆë‹¤.

## ì„¸íŠ¸ ë² ì´ìŠ¤ URI

ë” `setbaseuri` ì•¡ì…˜ì€ NFT ë©”íƒ€ë°ì´í„°ì˜ ê¸°ë³¸ URIë¥¼ ì„¤ì •í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ë§¤ê°œ ë³€ìˆ˜ í•˜ë‚˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.
- `base_uri` - NFT ë©”íƒ€ë°ì´í„°ì˜ ê¸°ë³¸ URI</details>


## ë°ì´í„° êµ¬ì¡° ì¶”ê°€

ì´ì œ ì‘ì—…ì„ ë§ˆì³¤ìœ¼ë‹ˆ NFTë¥¼ ì €ì¥í•  ë°ì´í„° êµ¬ì¡°ë¥¼ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤.

ìš°ë¦¬ëŠ” aë¥¼ ì‚¬ìš©í•  ê²ƒì…ë‹ˆë‹¤ `singleton` NFTë¥¼ ì €ì¥í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. 

>â” **ì‹±ê¸€í„´**
> >A `singleton` ê³¼ ë‹¬ë¦¬ ë²”ìœ„ë‹¹ í•˜ë‚˜ì˜ í–‰ë§Œ ê°€ì§ˆ ìˆ˜ ìˆëŠ” í…Œì´ë¸”ì…ë‹ˆë‹¤. `multi_index` ì–´ëŠ 
>ë²”ìœ„ë‹¹ ì—¬ëŸ¬ í–‰ì„ ê°€ì§ˆ ìˆ˜ ìˆìœ¼ë©° aë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. `primary_key` ê° í–‰ì„ ì‹ë³„í•©ë‹ˆë‹¤.
>ì‹±ê¸€í†¤ì€ ì´ë”ë¦¬ì›€ì˜ ìŠ¤í† ë¦¬ì§€ ëª¨ë¸ì— ì¡°ê¸ˆ ë” ê°€ê¹ìŠµë‹ˆë‹¤. 

ê³„ì•½ ì‹œ ì•¡ì…˜ ìœ„ì— ë‹¤ìŒ ì½”ë“œë¥¼ ì¶”ê°€í•˜ì„¸ìš”.

```cpp
    using _owners = singleton<"owners"_n, name>;
    using _balances = singleton<"balances"_n, uint64_t>;
    using _approvals = singleton<"approvals"_n, name>;
    using _approvealls = singleton<"approvealls"_n, name>;
    using _base_uris = singleton<"baseuris"_n, std::string>;
    
    ACTION mint...
```

ë‹¤ìŒê³¼ ê°™ì€ ì‹±ê¸€í„´ í…Œì´ë¸”ì„ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.
- `_owners` - í† í° IDì—ì„œ NFT ì†Œìœ ìë¡œì˜ ë§¤í•‘
- `_balances` - ì†Œìœ ìë³„ë¡œ ì†Œìœ í•œ NFT ìˆ˜ëŸ‰ì— ëŒ€í•œ ë§¤í•‘
- `_approvals` - í† í° IDì—ì„œ í•´ë‹¹ NFTë¥¼ ì „ì†¡í•˜ë„ë¡ ìŠ¹ì¸ëœ ê³„ì •ìœ¼ë¡œì˜ ë§¤í•‘
- `_approvealls` - ì†Œìœ ìë¥¼ ëª¨ë“  NFTë¥¼ ì´ì „í•˜ë„ë¡ ìŠ¹ì¸ëœ ê³„ì •ìœ¼ë¡œì˜ ë§¤í•‘
- `_base_uris` - NFT ë©”íƒ€ë°ì´í„°ì˜ ê¸°ë³¸ URIë¥¼ ì €ì¥í•˜ëŠ” êµ¬ì„± í…Œì´ë¸”

>â” **í…Œì´ë¸” ë„¤ì´ë°**
> > `singleton<"<TABLE NAME>"_n, <ROW TYPE>>`
> >ì‹±ê¸€í†¤ ì •ì˜ë¥¼ ë³´ë©´ í°ë”°ì˜´í‘œ ì•ˆì— í…Œì´ë¸” ì´ë¦„ì´ ìˆìŠµë‹ˆë‹¤.
>EOS í…Œì´ë¸”ì˜ ì´ë¦„ë„ ê³„ì • ì´ë¦„ ê·œì¹™ì„ ë”°ë¼ì•¼ í•©ë‹ˆë‹¤. ì¦‰, ë‹¤ìŒê³¼ ê°™ì•„ì•¼ í•©ë‹ˆë‹¤.
>12ì ì´í•˜ì´ë©°, ë‹¤ìŒ ë¬¸ìë§Œ í¬í•¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `a-z`, `1-5`, ë° `.`.

ì´ì œ NFTì— ëŒ€í•œ ë°ì´í„°ë¥¼ ì €ì¥í•  í…Œì´ë¸”ê³¼ êµ¬ì¡°ë¥¼ ë§Œë“¤ì—ˆìœ¼ë‹ˆ
ê° ë™ì‘ì— ëŒ€í•œ ë¡œì§ì„ ì±„ìš°ê¸° ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


## ì¼ë¶€ ë„ìš°ë¯¸ í•¨ìˆ˜ ì¶”ê°€

ì½”ë“œë¥¼ ë” ì½ê¸° ì‰½ê³  ì‰½ê²Œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ë„ìš°ë¯¸ í•¨ìˆ˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.
ìš©ë„.ê³„ì•½ì„œì— í‘œ ì •ì˜ ë°”ë¡œ ì•„ë˜ì— ë‹¤ìŒ ì½”ë“œë¥¼ ì¶”ê°€í•˜ì„¸ìš”.

```cpp
    using _base_uris = singleton<"baseuris"_n, std::string>;
    
    // Helper function to get the owner of an NFT
    name get_owner(uint64_t token_id){
        
        // Note that we are using the "token_id" as the "scope" of this table.
        // This lets us use singleton tables like key-value stores, which is similar
        // to how Ethereum contracts store data.
        
        _owners owners(get_self(), token_id);
        return owners.get_or_default(name(""));
    }
    
    // Helper function to get the balance of an account
    uint64_t get_balance(name owner){
        _balances balances(get_self(), owner.value);
        return balances.get_or_default(0);
    }
    
    // Helper function to get the account that is approved to transfer an NFT on your behalf
    name get_approved(uint64_t token_id){
        _approvals approvals(get_self(), token_id);
        return approvals.get_or_default(name(""));
    }
    
    // Helper function to get the account that is approved to transfer all of your NFTs on your behalf
    name get_approved_all(name owner){
      _approvealls approvals(get_self(), owner.value);
      return approvals.get_or_default(name(""));
   }
    
    // Helper function to get the URI of the NFT's metadata
    std::string get_token_uri(uint64_t token_id){
        _base_uris base_uris(get_self(), get_self().value);
        return base_uris.get_or_default("") + "/" + std::to_string(token_id);
    }
```

ë„ìš°ë¯¸ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ì´ì „ì— ë§Œë“  í…Œì´ë¸”ì—ì„œ ë°ì´í„°ë¥¼ ë” ì‰½ê²Œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ë‹¤ìŒì— êµ¬í˜„í•  ì‘ì—…ì—ì„œ ì´ëŸ¬í•œ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ê²ƒì…ë‹ˆë‹¤.

íŠ¹íˆ ì¼ë¶€ í•¨ìˆ˜ëŠ” ì—¬ëŸ¬ ê³³ì—ì„œ ì‚¬ìš©ë˜ë¯€ë¡œ ë‹¤ìŒê³¼ ê°™ì€ ê²ƒì´ í•©ë¦¬ì ì…ë‹ˆë‹¤.
ê·¸ë“¤ì„ ìœ„í•œ ë„ìš°ë¯¸ í•¨ìˆ˜ë¥¼ ë§Œë“œì„¸ìš”.ì˜ˆë¥¼ ë“¤ì–´, `get_owner` í•¨ìˆ˜ê°€ ì‚¬ìš©ë¨
ì—ì„œ `mint`, `transfer`, ë° `approve` í–‰ë™.í—¬í¼ í•¨ìˆ˜ë¥¼ ë§Œë“¤ì§€ ì•Šì€ ê²½ìš°
ì´ë¥¼ ìœ„í•´ì„œëŠ” ê° ì‘ì—…ì—ì„œ ë™ì¼í•œ ì½”ë“œë¥¼ ì‘ì„±í•´ì•¼ í•©ë‹ˆë‹¤.

## ì•¡ì…˜ ì±„ìš°ê¸°

ê° ì‘ì—…ì„ ì‚´í´ë³´ê³  ì´ì— ëŒ€í•œ ë¡œì§ì„ êµ¬í˜„í•´ ë³´ê² ìŠµë‹ˆë‹¤.ë‹¤ìŒ ì‚¬í•­ì— ì„¸ì‹¬í•œ ì£¼ì˜ë¥¼ ê¸°ìš¸ì´ì„¸ìš”
ê° ì½”ë“œ ì¤„ì˜ ê¸°ëŠ¥ì„ ì„¤ëª…í•˜ê¸° ìœ„í•´ ì£¼ì„ì„ ë‹¬ì•„ì£¼ì„¸ìš”.

### ë¯¼íŠ¸

ë” `mint` ì•¡ì…˜ì€ ìƒˆ NFTë¥¼ ë§Œë“œëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

```cpp
    ACTION mint(name to, uint64_t token_id){
        // We only want to mint NFTs if the action is called by the contract owner
        check(has_auth(get_self()), "only contract can mint");
        
        // The account we are minting to must exist
        check(is_account(to), "to account does not exist");
        
        // Get the owner singleton
        _owners owners(get_self(), token_id);
        
        // Check if the NFT already exists
        check(owners.get_or_default().value == 0, "NFT already exists");
        
        // Set the owner of the NFT to the account that called the action
        owners.set(to, get_self());
        
        // Get the balances table
        _balances balances(get_self(), to.value);
        
        // Set the new balances of the account
        balances.set(balances.get_or_default(0) + 1, get_self());
    }
```


### ì „ì†¡

ë” `transfer` ì•¡ì…˜ì€ í•œ ê³„ì •ì—ì„œ ë‹¤ë¥¸ ê³„ì •ìœ¼ë¡œ NFTë¥¼ ì´ì „í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

```cpp
    ACTION transfer(name from, name to, uint64_t token_id, std::string memo){
        // The account we are transferring from must authorize this action
        check(has_auth(from), "from account has not authorized the transfer");
        
        // The account we are transferring to must exist
        check(is_account(to), "to account does not exist");
        
        // The account we are transferring from must be the owner of the NFT
        // or allowed to transfer it through an approval
        bool ownerIsFrom = get_owner(token_id) == from;
        bool fromIsApproved = get_approved(token_id) == from;
        check(ownerIsFrom || fromIsApproved, "from account is not the owner of the NFT or approved to transfer the NFT");       
        
        // Get the owner singleton
        _owners owners(get_self(), token_id);
        
        // Set the owner of the NFT to the "to" account
        owners.set(to, get_self());
        
        // Set the new balance for the "from" account
        _balances balances(get_self(), from.value);
        balances.set(balances.get_or_default(0) - 1, get_self());
        
        // Set the new balance for the "to" account
        _balances balances2(get_self(), to.value);
        balances2.set(balances2.get_or_default(0) + 1, get_self());
        
        // Remove the approval for the "from" account
        _approvals approvals(get_self(), token_id);
        approvals.remove();
        
        // Send the transfer notification
        require_recipient(from);
        require_recipient(to);
    }
```

## ë°¸ëŸ°ìŠ¤ ì˜¤ë¸Œ

ë” `balanceof` ì•¡ì…˜ì€ ê³„ì • ì”ì•¡ì„ ê°€ì ¸ì˜¤ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

```cpp
    [[eosio::action]] uint64_t balanceof(name owner){
        return get_balance(owner);
    }
```

>âš  **ë°˜í™˜ ê°’ ë° êµ¬ì„± ê°€ëŠ¥ì„±**
> >ë°˜í™˜ ê°’ì€ ë¸”ë¡ì²´ì¸ ì™¸ë¶€ì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë©° í˜„ì¬ëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
>EOSì—ì„œ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ë¥¼ êµ¬ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.EOS ì§€ì› [**ì¸ë¼ì¸ ì•¡ì…˜**](/docs/03_smart-contracts/02_actions.md#inline-actions) ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”
>ë‹¤ë¥¸ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì„ í˜¸ì¶œí•  ìˆ˜ëŠ” ìˆì§€ë§Œ ê°’ì„ ë°˜í™˜í•  ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤.

## ì†Œìœ ì

ë” `ownerof` ì•¡ì…˜ì€ NFTì˜ ì†Œìœ ìë¥¼ ì–»ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

```cpp
    [[eosio::action]] name ownerof(uint64_t token_id){
        return get_owner(token_id);
    }
```

### ìŠ¹ì¸

ë” `approve` ì•¡ì…˜ì€ ê·€í•˜ë¥¼ ëŒ€ì‹ í•˜ì—¬ NFTë¥¼ ì–‘ë„í•  ê³„ì •ì„ ìŠ¹ì¸í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

```cpp
    ACTION approve(name to, uint64_t token_id){
        // get the token owner
        name owner = get_owner(token_id);
        
        // The owner of the NFT must authorize this action
        check(has_auth(owner), "owner has not authorized the approval");
    
        // The account we are approving must exist
        check(is_account(to), "to account does not exist");
        
        // Get the approvals table
        _approvals approvals(get_self(), token_id);
        
        // Set the approval for the NFT
        approvals.set(to, get_self());
    }
```

## ëª¨ë‘ ìŠ¹ì¸

ë” `approveall` ì•¡ì…˜ì€ ê³„ì •ì„ ìŠ¹ì¸í•˜ì—¬ ëª¨ë“  ê³„ì •ì„ ì´ì „í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
NFTê°€ ì—¬ëŸ¬ë¶„ì„ ëŒ€ì‹ í•´ ë“œë¦½ë‹ˆë‹¤.

```cpp
    ACTION approveall(name from, name to, bool approved){
        // The owner of the NFTs must authorize this action
        check(has_auth(from), "owner has not authorized the approval");
        
        // The account we are approving must exist
        check(is_account(to), "to account does not exist");
        
        // Get the approvals table
        _approvealls approvals(get_self(), from.value);
        
        if(approved){
            // Set the approval for the NFT
            approvals.set(to, get_self());
        } else {
            // Remove the approval for the NFT
            approvals.remove();
        }
    }
```

## ìŠ¹ì¸ ë°›ê¸°

ë” `getapproved` ì‘ì—…ì€ ì–‘ë„ê°€ ìŠ¹ì¸ëœ ê³„ì •ì„ ê°€ì ¸ì˜¤ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
NFTê°€ ì—¬ëŸ¬ë¶„ì„ ëŒ€ì‹ í•´ ë“œë¦½ë‹ˆë‹¤.

```cpp
    [[eosio::action]] name getapproved(uint64_t token_id){
        return get_approved(token_id);
    }
```

## 4ê°œ ëª¨ë‘ ìŠ¹ì¸ë¨

ë” `approved4all` ì•¡ì…˜ì€ ê³„ì • ì´ì „ ìŠ¹ì¸ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
ê·€í•˜ë¥¼ ëŒ€ì‹ í•˜ì—¬ ëª¨ë“  NFTë¥¼ ì œê³µí•©ë‹ˆë‹¤.

```cpp
    [[eosio::action]] bool approved4all(name owner, name approved_account){
      return get_approved_all(owner) == approved_account;
   }
```

>âš  **ì•¡ì…˜ ì´ë¦„ ì œí•œ**
> >ê³„ì • ì´ë¦„ì—ë„ í…Œì´ë¸” ì´ë¦„ê³¼ ë™ì¼í•œ ì œí•œì´ ìˆìœ¼ë¯€ë¡œ ë‹¤ìŒì„ í¬í•¨í•  ìˆ˜ë§Œ ìˆìŠµë‹ˆë‹¤.
>ìºë¦­í„°ë“¤ `a-z`, `1-5`, ë° `.`.ì´ ë•Œë¬¸ì— í‘œì¤€ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. `isApprovedForAll`
>ìš°ë¦¬ê°€ ì‚¬ìš©í•˜ê³  ìˆëŠ” ì•¡ì…˜ì˜ ì´ë¦„ `approved4all` ëŒ€ì‹ .

## í† í°ëˆ„ë¦¬

ë” `tokenuri` ì•¡ì…˜ì€ NFTì˜ URIë¥¼ ê°€ì ¸ì˜¤ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

```cpp
    [[eosio::action]] std::string tokenuri(uint64_t token_id){
        return get_token_uri(token_id);
    }
```

## ì„¸íŠ¸ ë² ì´ìŠ¤ URI

ë” `setbaseuri` ì•¡ì…˜ì€ NFTì˜ ê¸°ë³¸ URIë¥¼ ì„¤ì •í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

```cpp
    ACTION setbaseuri(std::string base_uri){
        // The account calling this action must be the contract owner
        require_auth(get_self());
        
        // Get the base URI table
        _base_uris base_uris(get_self(), get_self().value);
        
        // Set the base URI
        base_uris.set(base_uri, get_self());
    }
```



## ëª¨ë“  ê²ƒì„ í•˜ë‚˜ë¡œ ëª¨ìœ¼ê¸°

ì´ì œ ëª¨ë“  ì‘ì—…ì„ ì •ë¦¬í–ˆìœ¼ë‹ˆ ëª¨ë“  ì‘ì—…ì„ í•œ ê³³ì— ëª¨ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. `nft.cpp` íŒŒì¼.

ì•„ë˜ì˜ ì „ì²´ ê³„ì•½ì„ ì‚´í´ë³´ê¸° ì „ì— ì§ì ‘ ê³„ì•½ì„ êµ¬ì¶•í•˜ê³  ë°°í¬í•˜ê³  ìƒí˜¸ ì‘ìš©í•´ ë³´ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.
ë¨¼ì € ìì‹ ì´ ê´€ë¦¬í•˜ëŠ” ê³„ì •ì— ì¼ë¶€ NFTë¥¼ ë°œí–‰í•œ ë‹¤ìŒ ë‹¤ë¥¸ ê³„ì •ìœ¼ë¡œ ì´ì „í•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë˜í•œ ë‹¤ë¥¸ ê³„ì •ì„ ìŠ¹ì¸í•˜ì—¬ NFTë¥¼ ëŒ€ì‹  ì´ì „í•˜ì—¬ ìŠ¹ì¸ ë©”ì»¤ë‹ˆì¦˜ì„ í…ŒìŠ¤íŠ¸í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. 
ê·¸ëŸ° ë‹¤ìŒ ìŠ¹ì¸ëœ ê³„ì •ì„ ì‚¬ìš©í•˜ì—¬ ë‹¤ë¥¸ ê³„ì •ìœ¼ë¡œ ì´ì²´í•©ë‹ˆë‹¤.

<details>
 <summary>ì „ì²´ ê³„ì•½ì„ ë³´ë ¤ë©´ ì—¬ê¸°ë¥¼ í´ë¦­í•˜ì‹­ì‹œì˜¤</summary>

```cpp
#include <eosio/eosio.hpp>
#include <eosio/asset.hpp>
#include <eosio/singleton.hpp>
using namespace eosio;

CONTRACT nft : public contract {

   public:
   using contract::contract;

   // Mapping from token ID to owner
   using _owners = singleton<"owners"_n, name>;
   
   // Mapping owner address to token count
   using _balances = singleton<"balances"_n, uint64_t>;
   
   // Mapping from token ID to approved address
   using _approvals = singleton<"approvals"_n, name>;
   
   // Mapping from owner to operator approvals
   using _approvealls = singleton<"approvealls"_n, name>;
   
   // Registering the token URI
   using _base_uris = singleton<"baseuris"_n, std::string>;

   // Helper function to get the owner of an NFT
   name get_owner(uint64_t token_id){
      _owners owners(get_self(), token_id);
      return owners.get_or_default(name(""));
   }
   
   // Helper function to get the balance of an account
   uint64_t get_balance(name owner){
      _balances balances(get_self(), owner.value);
      return balances.get_or_default(0);
   }
   
   // Helper function to get the account that is approved to transfer an NFT on your behalf
   name get_approved(uint64_t token_id){
      _approvals approvals(get_self(), token_id);
      return approvals.get_or_default(name(""));
   }
   
   // Helper function to get the account that is approved to transfer all of your NFTs on your behalf
   name get_approved_all(name owner){
      _approvealls approvals(get_self(), owner.value);
      return approvals.get_or_default(name(""));
   }
   
   // Helper function to get the URI of the NFT's metadata
   std::string get_token_uri(uint64_t token_id){
      _base_uris base_uris(get_self(), get_self().value);
      return base_uris.get_or_default("") + "/" + std::to_string(token_id);
   }
   
   ACTION mint(name to, uint64_t token_id){
      // We only want to mint NFTs if the action is called by the contract owner
      check(has_auth(get_self()), "only contract can mint");

      // The account we are minting to must exist
      check(is_account(to), "to account does not exist");

      // Get the owner singleton
      _owners owners(get_self(), token_id);

      // Check if the NFT already exists
      check(owners.get_or_default().value == 0, "NFT already exists");

      // Set the owner of the NFT to the account that called the action
      owners.set(to, get_self());

      // Get the balances table
      _balances balances(get_self(), to.value);

      // Set the new balances of the account
      balances.set(balances.get_or_default(0) + 1, get_self());
   }
   
   ACTION transfer(name from, name to, uint64_t token_id, std::string memo){
      // The account we are transferring from must authorize this action
      check(has_auth(from), "from account has not authorized the transfer");

      // The account we are transferring to must exist
      check(is_account(to), "to account does not exist");

      // The account we are transferring from must be the owner of the NFT
      // or allowed to transfer it through an approval
      bool ownerIsFrom = get_owner(token_id) == from;
      bool fromIsApproved = get_approved(token_id) == from;
      check(ownerIsFrom || fromIsApproved, "from account is not the owner of the NFT or approved to transfer the NFT");       

      // Get the owner singleton
      _owners owners(get_self(), token_id);

      // Set the owner of the NFT to the "to" account
      owners.set(to, get_self());

      // Set the new balance for the "from" account
      _balances balances(get_self(), from.value);
      balances.set(balances.get_or_default(0) - 1, get_self());

      // Set the new balance for the "to" account
      _balances balances2(get_self(), to.value);
      balances2.set(balances2.get_or_default(0) + 1, get_self());

      // Remove the approval for the "from" account
      _approvals approvals(get_self(), token_id);
      approvals.remove();

      // Send the transfer notification
      require_recipient(from);
      require_recipient(to);
   }
   
   [[eosio::action]] uint64_t balanceof(name owner){
      return get_balance(owner);
   }
   
   [[eosio::action]] name ownerof(uint64_t token_id){
      return get_owner(token_id);
   }
   
   ACTION approve(name to, uint64_t token_id){
      // get the token owner
      name owner = get_owner(token_id);
      
      // The owner of the NFT must authorize this action
      check(has_auth(owner), "owner has not authorized the approval");
   
      // The account we are approving must exist
      check(is_account(to), "to account does not exist");
      
      // Get the approvals table
      _approvals approvals(get_self(), token_id);
      
      // Set the approval for the NFT
      approvals.set(to, get_self());
   }
   
   ACTION approveall(name from, name to, bool approved){
      // The owner of the NFTs must authorize this action
      check(has_auth(from), "owner has not authorized the approval");
      
      // The account we are approving must exist
      check(is_account(to), "to account does not exist");
      
      // Get the approvals table
      _approvealls approvals(get_self(), from.value);
      
      if(approved){
         // Set the approval for the NFT
         approvals.set(to, get_self());
      } else {
         // Remove the approval for the NFT
         approvals.remove();
      }
   }
   
   [[eosio::action]] name getapproved(uint64_t token_id){
      return get_approved(token_id);
   }
   
   [[eosio::action]] bool approved4all(name owner, name approved_account){
      return get_approved_all(owner) == approved_account;
   }
   
   [[eosio::action]] std::string gettokenuri(uint64_t token_id){
      return get_token_uri(token_id);
   }
   
   ACTION setbaseuri(std::string base_uri){
      // The account calling this action must be the contract owner
      require_auth(get_self());
      
      // Get the base URI table
      _base_uris base_uris(get_self(), get_self().value);
      
      // Set the base URI
      base_uris.set(base_uri, get_self());
   }
};
```
</details>

## êµìœ¡ ëª©ì ì„

ì´ ê³„ì•½ì„ EOS ë„¤íŠ¸ì›Œí¬ì— ë°°í¬í•˜ê³  í† í°ì„ ë°œí–‰í•˜ë©´ ê±°ê¸°ì„œ
íŒë§¤ë¥¼ ì§€ì›í•˜ëŠ” ë§ˆì¼“í”Œë ˆì´ìŠ¤ê°€ ì—†ì„ ê²ƒì…ë‹ˆë‹¤ (ì´ ê°€ì´ë“œë¥¼ ì‘ì„±í•  ë‹¹ì‹œì—ëŠ”).ì´ê²ƒì€ ë‹¨ì§€ êµìœ¡ ëª©ì ìœ¼ë¡œë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤.

## ì±Œë¦°ì§€

ì´ NFT ê³„ì•½ì€ NFTë¥¼ ì†Œê°í•  ë°©ë²•ì´ ì—†ìŠµë‹ˆë‹¤.ì¶”ê°€ `burn` í† í° ì†Œìœ ìê°€ ìì‹ ì˜ NFTë¥¼ ì†Œê°í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì¡°ì¹˜.
