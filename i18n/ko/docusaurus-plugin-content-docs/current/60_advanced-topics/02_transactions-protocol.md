---
title: 트랜잭션 프로토콜
---


## 1.개요

액션은 스마트 컨트랙트 내의 원자적 행동을 정의합니다.상위 수준에서 트랜잭션은 분산된 애플리케이션 내에서 원자적으로 실행되는 작업 그룹을 정의합니다.데이터베이스 트랜잭션과 마찬가지로, 블록체인 트랜잭션을 구성하는 작업 그룹은 모두 미리 정의된 순서대로 하나씩 성공해야 합니다. 그렇지 않으면 트랜잭션이 실패합니다.트랜잭션이 실패할 경우 트랜잭션의 원자성과 무결성을 유지하기 위해 블록체인 상태는 트랜잭션을 처리하기 전의 상태와 일치하는 상태로 복원됩니다.이를 통해 장애 시점 이전에 실행된 작업으로 인한 부작용이 발생하지 않습니다.


### 1.1.액션

이전에 블록체인에서 생성된 한 명 이상의 행위자가 작업을 승인할 수 있습니다.액션은 스마트 컨트랙트 내에서 명시적으로 생성되거나 애플리케이션 코드에 의해 암시적으로 생성될 수 있습니다.주어진 모든 것에 대해 `actor:action` 한 쌍에는 최대 하나의 명시적 관련 최소 권한이 있습니다.명시적인 최소 권한 설정이 없는 경우 암시적 기본값은 다음과 같습니다. `actor@active`.각 행위자는 주어진 액션에 대해 개인적인 최소 권한을 독립적으로 설정할 수 있습니다.또한 EOS 소프트웨어 내에는 복잡하지만 유연한 권한 부여 구조가 마련되어 있어 행위자가 다른 계정을 대신하여 조치를 취할 수 있습니다.따라서 액터가 액션을 보낼 수 있는 권한을 부여하기 위한 추가 검사가 시행됩니다 (참조). [3.4.2.권한 확인](#342-permission-check)).

트랜잭션에는 두 가지 유형의 작업이 포함됩니다.주로 EOS 소프트웨어에서 실행되는 방식이 다릅니다.

1.서명된 트랜잭션에 존재하는 명시적 행위 (참조) [2.트랜잭션 인스턴스](#2-transaction-instance)).
2.암시적 (인라인) 액션은 트랜잭션 처리의 부작용으로 생성됩니다.

암시적 (인라인) 액션도 명시적 액션과 마찬가지로 스마트 컨트랙트 코드에서 정의됩니다.주요 차이점은 인라인 액션은 네트워크를 통해 전파되어 결국에는 블록에 포함되는 실제 트랜잭션에 포함되지 않고 암시적이라는 것입니다.


### 1.1.1.명시적 조치

이름에서 알 수 있듯이 정기적이거나 명시적인 작업은 트랜잭션을 구성하는 실제 작업 목록에 포함됩니다.명시적 액션은 액션 인스턴스로 인코딩됩니다 (참조). [3.4.3.액션 인스턴스](#343-action-instance)) 트랜잭션에 푸시되기 전에명시적 작업에는 트랜잭션의 일부로 실행될 작업과 관련된 실제 페이로드 데이터 (있는 경우) 도 포함됩니다.


#### 1.1.2.암시적 액션

암시적 (인라인) 작업은 트랜잭션 내의 명시적 호출자 작업 (또는 중첩된 경우 다른 인라인 작업) 의 결과로 생성되며, 호출자 작업이 계속되려면 해당 암시적 작업이 작업을 수행해야 합니다.따라서 인라인 작업은 호출자 작업과 동일한 범위 및 권한 내에서 작동합니다.따라서 인라인 작업은 동일한 트랜잭션 내에서 실행되도록 보장됩니다.


### 1.2.스마트 컨트랙트

EOS에서 스마트 계약은 일반적으로 기능별로 그룹화된 일련의 작업과 이러한 작업이 의존하는 일련의 유형 정의로 구성됩니다.따라서 액션은 계약의 실제 행동을 지정하고 정의합니다.표준 EOS 계약에는 계정 생성, 생산자 투표, 토큰 운영 등에 대한 몇 가지 조치가 구현되어 있습니다. 애플리케이션 개발자는 자체 스마트 계약 및 애플리케이션 내에서 사용자 지정 작업을 생성하여 이 기능을 확장, 대체 또는 비활성화할 수 있습니다.반면 트랜잭션은 일반적으로 애플리케이션 수준에서 생성됩니다.스마트 콘트랙트는 영향을 받지 않습니다.


### 1.2.1.구현

EOS 스마트 계약은 다음에서 파생되는 C++ 클래스로 구현됩니다. `eosio::contract`.액션은 파생 클래스 내에서 C++ 메서드로 구현됩니다.반면 트랜잭션은 EOS 애플리케이션 내에서 동적으로 (트랜잭션 인스턴스로) 생성됩니다.EOS 소프트웨어는 각 트랜잭션 인스턴스를 처리하고 생성, 서명, 검증 및 실행으로 발전함에 따라 상태를 추적합니다.


## 2.트랜잭션 인스턴스

트랜잭션 인스턴스는 트랜잭션 헤더와 실제 트랜잭션을 만드는 액션 인스턴스 및 트랜잭션 확장 목록으로 구성됩니다.트랜잭션 헤더에는 트랜잭션이 실행을 위해 푸시될 때 계산되는 만료 시간을 기준으로 트랜잭션이 블록에 포함되는지 평가하는 데 필요한 정보가 포함됩니다.기타 필드에는 트랜잭션을 포함하는 블록 번호, “크로스 체인” 또는 “크로스 포크” 공격을 방지하는 데 사용되는 블록 ID 접두사, CPU 및 네트워크 사용량 상한선, 트랜잭션 지연 시간 (초) 등이 있습니다 (해당하는 경우).아래 다이어그램은 트랜잭션 인스턴스를 보여줍니다.

![](/images/protocol-xacts_instance.png "Transaction Instance")

액션 인스턴스는 일반 액션 또는 컨텍스트 프리 액션으로 구성될 수 있습니다.서명은 트랜잭션 수준에서 생성되고 검증됩니다.계정과 권한은 작업별로 처리됩니다.각 작업 인스턴스에는 작업에 지정된 행위자의 권한 수준과 해당 작업에 대해 스마트 계약에 정의된 실제 권한을 기반으로 실행 권한이 있는지 여부를 검증하는 정보가 포함되어 있습니다 (참조). [3.4.2.권한 확인](#342-permission-check)).


### 2.1.거래 ID

트랜잭션 인스턴스에는 한 트랜잭션을 다른 트랜잭션과 구분하는 최소 필드 집합이 포함됩니다.따라서 트랜잭션 ID는 트랜잭션 인스턴스에 포함된 기본 필드의 암호화 해시로 구성됩니다.따라서 트랜잭션 ID는 트랜잭션 내에 캡슐화된 작업 목록, 트랜잭션 헤더 및 내장된 트랜잭션 확장 (선택 사항) 에 의해서만 결정됩니다.트랜잭션 인스턴스는 서명된 트랜잭션 인스턴스 또는 패킹된 트랜잭션 인스턴스로 더욱 전문화될 수 있습니다.


### 2.2.서명된 트랜잭션 인스턴스

서명된 트랜잭션은 트랜잭션에 서명한 계정에서 생성된 서명을 포함하도록 트랜잭션 스키마의 기본 내용을 확장합니다.또한 트랜잭션 인스턴스에 포함된 컨텍스트 프리 작업 (있는 경우) 과 관련된 모든 데이터도 포함됩니다 (참조). `signed_transaction` 아래 스키마).해당 행위자가 서명하지 않는 한 트랜잭션은 실행 및 검증할 준비가 되지 않았습니다.

#### 서명된 트랜잭션 스키마

이름 | 유형 | 설명
-|-|-
`expiration` | `time_point_sec` | 거래가 만료되기 전까지 확인되어야 하는 시간
`ref_block_num` | `uint16_t` | 마지막 $2^ {16} $ 블록에 있는 블록 번호의 하위 16비트
`ref_block_prefix` | `uint32_t` | 에서 참조하는 블록 ID의 하위 32비트 ref_block_num'
`max_net_usage_words` | `unsigned_int` | 청구되는 총 네트워크 대역폭의 상한선 (64비트 단어)
`max_cpu_usage_ms` | `uint8_t` | 청구되는 총 CPU 시간의 상한선 (밀리초 단위)
`delay_sec` | `unsigned_int` | 트랜잭션을 지연하는 데 걸리는 시간 (초)
`context_free_actions` | 배열 `action` | 컨텍스트가 없는 작업 목록 (있는 경우)
`actions` | 배열 `action` | 목록 [액션 인스턴스](#343-action-instance)
`transaction_extensions` | `extensions_type` | 필드를 확장하여 추가 기능 지원
`signatures` | 배열 `signature_type` | 거래 서명 후 디지털 서명
`context_free_data` | 배열 `bytes` | 컨텍스트가 없는 작업 데이터 (있는 경우 전송 가능)


### 2.3.패킹 트랜잭션 인스턴스

압축 트랜잭션은 선택적으로 압축된 서명된 트랜잭션으로, 압축을 해제하고 신속하게 검증할 수 있도록 하우스키핑 필드를 추가할 수 있습니다.패키지 트랜잭션은 장기적으로 공간 풋프린트와 블록 크기를 최소화합니다 (참조). `packed_transaction` 아래 스키마).팩 트랜잭션은 EOS 블록체인에서 가장 일반적인 유형의 트랜잭션을 형성합니다.따라서 트랜잭션이 블록으로 푸시되면 압축 여부에 관계없이 실제로는 압축된 트랜잭션입니다.

#### 패킹된 트랜잭션 스키마

이름 | 유형 | 설명
-|-|-
`signatures` | `signature_type` | 거래 서명 후 디지털 서명
`compression` | `compression_type` | 압축 방법 사용
`packed_context_free_data` | `bytes` | 컨텍스트가 없는 압축된 데이터 (트랜잭션이 압축된 경우)
`packed_trx` | `bytes` | 압축된 트랜잭션 (압축된 경우)
`unpacked_trx` | `signed_transaction` | 캐시된 압축 해제된 트랜잭션
`trx_id` | `transaction_id_type` | 거래 ID

더 `unpacked_trx` field는 트랜잭션 인스턴스가 생성된 후 캐시된 압축이 풀린 트랜잭션을 보유합니다.서명된 트랜잭션이 이전에 압축된 경우 압축이 풀립니다. `packed_trx` 필드 및 캐시 대상 `unpacked_trx`.서명된 트랜잭션이 압축되지 않은 상태로 저장된 경우 간단히 다음 위치에 그대로 복사됩니다. `unpacked_trx`.더 `signatures` 필드를 사용하면 트랜잭션을 완전히 압축 해제하지 않고도 트랜잭션의 빠른 서명 검증을 수행할 수 있습니다.


## 3.트랜잭션 라이프사이클

거래는 수명 기간 동안 다양한 단계를 거칩니다.먼저, 관련 작업을 트랜잭션에 푸시하여 애플리케이션 또는 Cleos와 같은 EOS 클라이언트에서 트랜잭션을 생성합니다.그런 다음 트랜잭션은 로컬로 연결된 노드로 전송되고, 이 노드는 이를 P2P 네트워크를 통해 검증 및 실행을 위해 활성 생산 노드로 전달합니다.다음으로, 유효한 트랜잭션은 다른 트랜잭션과 함께 일정에 따라 활성 생산자에 의해 블록으로 푸시됩니다.마지막으로 트랜잭션을 포함하는 블록이 검증을 위해 다른 모든 노드로 푸시됩니다.생산자의 과반수가 블록을 검증하고 블록이 되돌릴 수 없게 되면 트랜잭션은 블록체인에 영구적으로 기록되고 변경할 수 없는 것으로 간주됩니다.


### 3.1.거래 생성

트랜잭션은 트랜잭션 객체를 인스턴스화하고 관련 작업 인스턴스를 트랜잭션 인스턴스 내의 목록으로 푸시하여 애플리케이션 내에서 생성됩니다.액션 인스턴스에는 액션을 받을 대상 수신자 계정에 대한 실제 세부 정보, 액션의 이름, 서명과 지연을 통해 트랜잭션을 승인해야 하는 행위자 목록 및 권한 수준, 전송될 실제 메시지 (있는 경우) 에 대한 실제 세부 정보가 포함됩니다 (참조). `action` 아래 스키마).

#### 액션 스키마

이름 | 유형 | 설명
-|-|-
`account` | `name` | 인코딩된 13자 계정 이름
`action_name` | `name` | 인코딩된 13자 액션 이름
`authorization` | 배열 `permission_level` | 목록 `actor:permission` 승인
`data` | `bytes` | 전송할 작업 데이터

애플리케이션 수준에서 트랜잭션 인스턴스가 생성되면 트랜잭션이 처리되도록 정렬됩니다.여기에는 트랜잭션에 서명하는 단계와 트랜잭션의 실제 전파 및 실행을 위해 서명된 트랜잭션을 로컬 노드로 푸시하는 두 가지 주요 단계가 포함됩니다.이러한 단계는 일반적으로 EOS 애플리케이션 내에서 수행됩니다.


## 3.2.거래 서명

누적된 명시적 세트를 만족시키기에 충분한 키 집합으로 트랜잭션에 서명해야 합니다. `actor:permission` 트랜잭션에 포함된 모든 액션에 지정된 쌍입니다.이 연결은 주어진 권한에 대한 권한 테이블을 통해 이루어집니다.실제 서명 키는 애플리케이션이 실행되는 클라이언트에서 서명 계정과 연결된 지갑을 쿼리하여 얻습니다.

트랜잭션 서명 프로세스에는 서명할 트랜잭션 인스턴스, 애플리케이션 지갑 내의 관련 개인 키를 가져오는 공개 키 세트, 체인 ID라는 세 가지 파라미터가 사용됩니다.체인 ID는 실제 EOS 블록체인을 식별하며 블록체인의 초기 구성 매개변수에 따라 달라지는 생성 상태의 해시로 구성됩니다.트랜잭션에 서명하기 전에 EOS 소프트웨어는 먼저 트랜잭션의 다이제스트를 계산합니다.다이제스트 값은 체인 ID, 트랜잭션 인스턴스 및 트랜잭션에 컨텍스트 프리 작업이 있는 경우 컨텍스트 프리 데이터의 SHA-256 해시입니다.모든 인스턴스 필드는 해시 계산에 참조 필드 (메모리 주소) 가 포함되지 않도록 암호화 해시를 계산하기 전에 직렬화됩니다.트랜잭션 다이제스트 계산 및 서명 프로세스는 다음과 같습니다.

![](/images/protocol-xact_sign.png "Transaction Signing")

트랜잭션 다이제스트가 계산된 후 최종적으로 서명 계정의 공개 키와 연결된 개인 키로 다이제스트에 서명됩니다.공개-개인 키 쌍은 일반적으로 로컬 노드에 연결된 로컬 시스템 내에 저장됩니다.서명 프로세스는 일반적으로 애플리케이션을 배포하는 동일한 사용자인 서명 계정과 연결된 지갑 관리자 내에서 수행됩니다.지갑 관리자는 디지털 서명을 수행할 수 있는 가상 보안 구역을 제공하므로 개인 키가 지갑을 떠나지 않고도 메시지 서명이 생성됩니다.서명이 생성되면 최종적으로 서명된 트랜잭션 인스턴스에 추가됩니다.


## 3.3.푸시 트랜잭션

트랜잭션이 서명되면 서명된 트랜잭션 인스턴스에서 패킹된 트랜잭션 인스턴스가 생성되어 애플리케이션에서 로컬 노드로 푸시되고, 로컬 노드는 서명 확인, 실행 및 검증을 위해 트랜잭션을 활성 생산 노드로 전달합니다.트랜잭션을 수신하는 모든 프로덕션 노드는 트랜잭션을 다음 프로덕션 노드로 전달하기 전에 로컬 컨텍스트에서 트랜잭션을 실행하고 검증하려고 시도합니다.따라서 유효한 트랜잭션은 릴레이되고 유효하지 않은 트랜잭션은 삭제됩니다.이를 뒷받침하는 아이디어는 악의적인 공격자가 가짜 트랜잭션으로 네트워크에 스팸을 보내는 것을 방지하는 것입니다.잘못된 거래는 예정된 일정에 따라 활성 생산자에게 도달하기 전에 필터링되어 삭제될 것으로 예상됩니다.거래가 접수되면 그 유효성에 대한 어떠한 가정도 이루어지지 않습니다.모든 트랜잭션은 블록을 생성하는지 여부에 관계없이 다음 생산 노드에 의해 다시 검증됩니다.유일한 차이점은 생산자가 일정에 따라 검증한 트랜잭션을 보류 중인 블록으로 푸시한 후 최종 블록을 자체 로컬 체인으로 푸시하여 다른 노드에 릴레이하는 방식으로 블록을 생성하려고 시도한다는 것입니다.


## 3.4.거래 확인

거래를 확인하는 프로세스는 두 가지입니다.먼저, 트랜잭션에 서명한 계정과 관련된 공개 키가 트랜잭션에 제공된 서명 세트에서 복구됩니다.EOS에서 사용되는 타원 곡선 디지털 서명 알고리즘인 ECDSA에서는 이러한 복구가 암호학적으로 가능합니다.둘째, 트랜잭션에 포함된 각 작업의 작업 권한 목록 (actor:permission) 에 지정된 각 행위자의 공개 키를 복구된 키 집합과 비교하여 만족하는지 확인합니다.셋째, 각각 만족 `actor:permission` 해당 작업에 필요한 관련 최소 권한과 대조하여 확인됩니다. `actor:contract::action` 쌍을 이루어 해당 최소값을 충족하거나 초과하는지 확인하십시오.이 마지막 검사는 작업이 실행되기 전에 작업 수준에서 수행됩니다 (참조). [3.4.2.권한 확인](#342-permission-check)).


### 3.4.1.트랜잭션 컨텍스트

공개 키가 복구되면 트랜잭션 인스턴스에서 트랜잭션 컨텍스트가 생성됩니다.트랜잭션 컨텍스트는 작업의 추적을 추적하고 각 작업이 전달되고 실행될 때 생성되는 작업 수신을 추적합니다.생성된 모든 상태는 트랜잭션 추적 인스턴스와 작업 수신 목록에 보관됩니다.트랜잭션 추적은 작업 추적 목록으로 구성됩니다.각 작업 추적에는 실행된 작업에 대한 정보 (작업 수신, 작업 인스턴스, 컨텍스트가 없는 작업인지 여부, 작업을 생성한 트랜잭션 ID 등) 가 포함됩니다.조치 영수증은 나중에 트랜잭션 실행 및 완료 중에 생성됩니다.


### 3.4.2.권한 확인

트랜잭션에 포함된 일련의 작업을 전체적으로 원자적으로 실행해야 하므로 EOS 소프트웨어는 먼저 각 작업에 지정된 행위자가 이를 실행하는 데 필요한 최소 권한을 가지고 있는지 확인합니다.이를 위해 소프트웨어는 각 작업에 대해 다음을 확인합니다.

* 각 액션 인스턴스에 지정된 각 액터의 지정된 권한.
* 해당 기관의 기명 허가 `actor:contract::action` 스마트 컨트랙트에 지정된 쌍

명명된 권한 집합이 해당 작업자가 요구하는 최소 권한 수준을 충족하지 못하는 행위자가 한 명 이상 있는 경우 `actor:contract::action` 스마트 컨트랙트에서 페어링하면 트랜잭션이 실패합니다.작업을 실행하기 전에 작업 권한을 확인하는 이유는 성능 때문입니다.몇 가지 작업을 실행한 후 나중에 작업 또는 권한 부여가 실패하여 롤백되는 것보다 모든 작업이 실행되지 않은 상태에서 트랜잭션을 취소하는 것이 더 효율적입니다.데이터 무결성을 유지하려면 작업 실패 중에 발생한 모든 상태 변경을 취소해야 합니다.데이터베이스 세션은 메모리 사용량 및 컴퓨팅 리소스 측면에서 비용이 많이 듭니다.따라서 실행 취소 작업을 최대한 최소화해야 합니다.


### 3.4.3.액션 인스턴스

아래 다이어그램은 액션 인스턴스를 보여줍니다.수신자 계정, 작업 이름, 행위자 목록 및 권한, 수신자 계정으로 보낼 메시지 (있는 경우) 가 포함된 작업 데이터로 구성됩니다.

![](/images/protocol-xacts_act_instance.png "Action Instance")

### 3.4.4.권한 확인

최소 권한 수준을 확인한 후 액션 인스턴스 내에서 각 액터의 권한과 일치하는 수신자 계정의 권한에 대한 권한 테이블을 확인합니다.


### 3.5.트랜잭션 실행

트랜잭션을 실행하기 위해 체인 데이터베이스 세션이 시작되고 스냅샷이 생성됩니다.이를 통해 트랜잭션 작업이 실패할 경우 체인 상태에 대한 모든 변경 사항을 롤백할 수 있습니다.해당 트랜잭션 컨텍스트는 실행 중에 트랜잭션 상태를 유지합니다.트랜잭션을 실행하기 위해 해당 트랜잭션 인스턴스와 관련된 각 작업이 실행을 위해 디스패치됩니다.컨텍스트가 없는 작업 (있는 경우) 이 먼저 전달되고 그 다음에 일반 작업이 전달됩니다.


### 3.5.1.컨텍스트 적용

작업 실행을 준비하기 위해 각 작업에 대해 로컬에 적용 컨텍스트 인스턴스가 작성됩니다.적용 컨텍스트는 이름에서 알 수 있듯이 체인 컨트롤러에 대한 인스턴스와 같이 작업을 적용하는 데 필요한 리소스에 대한 참조를 포함합니다 (참조). [네트워크 피어 프로토콜: 2.2.체인 컨트롤러](03_network-peer-protocol.md#22-chain-controller)), 상태가 유지되는 체인 데이터베이스, 트랜잭션이 실행되는 트랜잭션 컨텍스트, 실제 작업 인스턴스 및 작업이 예정된 수신자 계정.


#### 3.5.2.액션 트레이스

각 작업의 실행을 준비하기 위해 작업 수신 및 작업 추적 인스턴스가 모두 초기화됩니다.먼저, 액션 인스턴스 자체의 해시가 계산되어 액션 수신에 저장됩니다.다음으로, 작업이 포함된 트랜잭션이 푸시될 보류 중인 블록에 대한 통계로 작업 추적이 초기화됩니다.따라서 작업 추적을 사용하면 블록을 생성한 실제 노드를 포함하여 작업이 포함된 실제 블록 및 트랜잭션까지 작업을 추적할 수 있습니다.마지막으로, 핸들러 이름, 수신자 계정, 액터 계정을 생산 노드 내에서 체인 컨트롤러가 관리하는 액션 핸들러 목록과 매칭시켜 액션 핸들러를 찾습니다.이러한 작업 핸들러는 시스템이 계약되고 클라이언트 애플리케이션이 로드될 때 컨트롤러에 적용됩니다.핸들러는 수신자 계정 이름, 계약 이름, 작업 이름 및 작업 핸들러를 사용합니다.


#### 3.5.3.액션 실행

적절한 액션 핸들러를 찾으면 적절한 화이트리스트와 블랙리스트가 확인됩니다.노드가 현재 블록을 생성하고 있는 경우, 수신자 계정은 계정 화이트리스트 및 블랙리스트 (있는 경우) 와 대조하여 확인됩니다.액션 블랙리스트가 있으면 다음에 확인합니다.수신자 계정이나 작업 이름이 블랙리스트에 있으면 작업이 중단됩니다.수신자 계정이 이미 화이트리스트에 있는 경우 블랙리스트 확인은 생략됩니다.모든 검사가 통과되면 해당 작업 핸들러를 호출하고 액터 계정을 전달하여 액션이 최종적으로 실행됩니다. `from` 매개 변수 및 내 수신 계정 `to` 파라미터.


## 3.6.거래 마무리

트랜잭션에 포함된 모든 작업이 실행되면 트랜잭션은 마무리 단계에 들어갑니다.이 단계에서는 각 작업에 대해 해당 조치 영수증이 생성됩니다.작업 수신에는 해당 작업 인스턴스의 해시, 분석에 사용되는 몇 가지 카운터, 작업의 대상 수신자 계정 (해당하는 경우) 이 포함됩니다.


### 3.6.1.거래 영수증

거래에 대한 모든 조치 영수증이 생성되면 최종적으로 거래 영수증이 생성되어 블록에 포함된 다른 거래 영수증과 함께 서명된 블록으로 푸시됩니다.트랜잭션 영수증에는 마이크로초 단위로 청구된 실제 CPU 양과 사용된 총 NET 스토리지를 포함하여 트랜잭션 결과 (실행, 미실행, 실패, 지연, 만료 등) 가 요약됩니다 (참조). `transaction_receipt` 아래 스키마).

##### 트랜잭션_영수증 스키마

이름 | 유형 | 설명
-|-|-
`status` | `uint8_t` | 트랜잭션 실행 시도 결과
`cpu_usage_us` | `uint32_t` | 총 CPU 사용량 (마이크로초 단위)
`net_usage_words` | `unsigned int` | 64비트 워드에서 사용된 총 NET의 수
`trx` | `variant` | 거래 ID 또는 포장 거래 보유

더 `status` field는 다음 결과 중 하나를 포함할 수 있는 8비트 열거형입니다.

* `executed` - 트랜잭션이 성공했습니다. 오류 처리기가 실행되지 않았습니다.
* `soft_fail` - 트랜잭션 실패, 오류 처리기 성공
* `hard_fail` - 트랜잭션 실패, 오류 핸들러 실패.
* `delayed` - 향후 실행을 위해 사용자가 거래를 지연합니다.
* `expired` - 거래 만료, CPU/NET이 사용자에게 환불되었습니다.

>ℹ️ 더 `delayed` 상태는 **지연된 사용자 거래**, 즉 승인을 충족하는 데 지연이 있는 명시적인 사용자 생성 거래에만 적용됩니다 (참조). [3.6.3.지연된 사용자 거래](#363-delayed-user-transactions) 자세한 내용은 여기를 참조하십시오).

더 `trx` 필드에는 트랜잭션 ID 또는 패킹된 트랜잭션 자체가 들어 있습니다.실제 선택은 거래 유형에 따라 달라집니다.지연된 거래 및 지연된 사용자 거래에서 생성된 영수증은 거래 ID별로 저장되며, 다른 모든 유형은 묶음 거래로 저장됩니다.

### 3.6.2.지연된 트랜잭션

지연된 트랜잭션은 블록체인 처리의 부작용으로 생성되므로 해당 상태는 블록 내부가 아닌 체인 데이터베이스에 저장됩니다.따라서 거래 영수증에 해당 내용을 명시적으로 포함할 필요가 없습니다.모든 동기화 노드는 합의에 따라 지연된 트랜잭션의 형태를 인식해야 합니다.스마트 컨트랙트에 의해 발행된 지연된 거래는 스마트 컨트랙트에 아무런 역할이나 영향을 미치지 않습니다. `delayed` 거래 영수증의 상태 필드.

>⚠ **경고: **
>지원 중단 공지
>지연된 트랜잭션은 EOS 2.0부터 더 이상 사용되지 않습니다.

### 3.6.3.지연된 사용자 거래

지연된 사용자 트랜잭션에는 패킹된 트랜잭션이 네트워크로 푸시될 때 (지연 타이머 시작 시) 포함됩니다.그러나 일반 거래와 달리 “지연된” 상태이므로 실행 및 검증이 연기될 수 있습니다.나중에 실행/실패/만료될 때 (지연 타이머 종료 시) 에는 트랜잭션 ID만 포함됩니다.동기화 중인 모든 노드에는 이전 브로드캐스트 블록의 트랜잭션 콘텐츠가 있기 때문입니다.


## 3.7.거래 검증

트랜잭션은 수명 주기 동안 다양한 단계에서 검증되고 검증됩니다. 처음에는 P2P 네트워크에서 느슨한 트랜잭션으로 전파될 때 (참조). [3.4.거래 확인](#34-verify-transaction)) 를 선택한 후 블록 검증 중에 대다수의 블록 생산자 사이에서 블록이 확인되고, 선택적으로 노드가 리플레이 중에 트랜잭션을 완전히 재검증하도록 구성된 경우 블록체인 리플레이 중에 가능합니다.기본적으로 기록된 트랜잭션은 리플레이 중에 완전히 재검증되지 않습니다. 노드 운영자가 개인적으로 또는 부채널을 통해 로컬 블록 로그에 대한 신뢰를 구축한 것으로 간주되어 더 이상 비잔틴 정보의 잠재적 출처로 간주되지 않기 때문입니다.


### 3.7.1.검증 프로세스

블록의 일부로 트랜잭션을 검증하는 경우 다양한 수준에서 여러 검증이 발생합니다.전체 블록 검증에서는 블록에 기록된 모든 트랜잭션이 재생되고 로컬에서 계산된 머클 트리 루트 해시 (각각 트랜잭션 수신 데이터 및 액션 수신 데이터에서 생성됨) 를 다음과 비교합니다. `transaction_mroot` 과 `action_mroot` 블록 헤더의 필드.따라서 기록된 트랜잭션이 블록 내에서 변조되면 머클 트리 루트 해시가 불일치를 야기할 뿐만 아니라 트랜잭션 서명도 검증하지 못할 수 있습니다.선의의 블록 생산자가 변조를 수행하지 않았다면 블록 서명의 검증도 실패할 것입니다 (참조 [컨센서스 프로토콜: 5.3.블록 검증](01_consensus-protocol.md#53-block-validation)).
