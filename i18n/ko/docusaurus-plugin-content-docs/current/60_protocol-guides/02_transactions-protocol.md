---
title: 트랜잭션 프로토콜
---


## 1. 개요

작업은 스마트 계약 내에서 원자적 동작을 정의합니다. 더 높은 수준에서 트랜잭션은 분산 응용 프로그램 내에서 원자적으로 실행되는 작업 그룹을 정의합니다. 데이터베이스 트랜잭션과 유사하게 블록체인 트랜잭션을 구성하는 작업 그룹은 미리 정의된 순서대로 하나씩 모두 성공해야 합니다. 그렇지 않으면 트랜잭션이 실패합니다. 트랜잭션이 실패한 경우 트랜잭션 원자성과 무결성을 유지하기 위해 블록체인 상태는 트랜잭션을 처리하기 전 상태와 일치하는 상태로 복원됩니다. 이렇게 하면 실패 지점 이전에 실행된 작업으로 인해 부작용이 발생하지 않습니다.


### 1.1. 행위

작업은 블록체인에서 이전에 생성된 하나 이상의 행위자에 의해 승인될 수 있습니다. 작업은 스마트 계약 내에서 명시적으로 생성되거나 애플리케이션 코드에 의해 암시적으로 생성될 수 있습니다. 어떤 주어진 `actor:action` 쌍에는 최대 하나의 명시적으로 연결된 최소 권한이 있습니다. 명시적인 최소 권한이 설정되지 않은 경우 암시적 기본값은 다음과 같습니다. `actor@active`. 각 액터는 주어진 작업에 대한 개인 최소 권한을 독립적으로 설정할 수 있습니다. 또한 EOS 소프트웨어 내에는 복잡하지만 유연한 인증 구조가 있어 액터가 다른 계정을 대신하여 조치를 취할 수 있습니다. 따라서 액터가 작업을 보낼 권한을 부여하기 위해 추가 검사가 시행됩니다(참조 [3.4.2. 권한 확인](#342-permission-check)).

트랜잭션과 관련된 두 가지 유형의 작업이 있습니다. 주로 EOS 소프트웨어에서 실행되는 방식이 다릅니다.

1. 서명된 트랜잭션에 있는 명시적 작업(참조 [2. 트랜잭션 인스턴스](#2-transaction-instance)).
2. 트랜잭션 처리의 부작용으로 생성되는 암시적(인라인) 작업.

암시적(인라인) 작업도 명시적 작업과 마찬가지로 스마트 계약 코드에서 정의됩니다. 주요 차이점은 인라인 작업은 네트워크를 통해 전파되는 실제 트랜잭션에 포함되지 않고 결국 블록에 포함된다는 것입니다. 그것들은 암시적입니다.


#### 1.1.1. 명시적 작업

이름에서 알 수 있듯이 일반 또는 명시적 작업은 트랜잭션을 형성하는 실제 작업 목록에 포함됩니다. 명시적 작업은 작업 인스턴스로 인코딩됩니다(참조: [3.4.3. 액션 인스턴스](#343-action-instance)) 트랜잭션에 푸시되기 전에. 명시적 작업에는 트랜잭션의 일부로 실행될 작업과 관련된 실제 페이로드 데이터(있는 경우)도 포함됩니다.


#### 1.1.2. 암시적 작업

암시적(인라인) 작업은 호출자 작업이 계속되도록 작업을 수행하기 위해 암시적 작업이 필요한 트랜잭션(또는 중첩된 경우 다른 인라인 작업) 내의 명시적 호출자 작업의 결과로 생성됩니다. 따라서 인라인 작업은 호출자 작업과 동일한 범위 및 권한 내에서 작동합니다. 따라서 인라인 작업은 동일한 트랜잭션 내에서 실행되도록 보장됩니다.


### 1.2. 스마트 계약

EOS에서 스마트 계약은 일반적으로 기능별로 그룹화된 작업 세트와 해당 작업이 의존하는 유형 정의 세트로 구성됩니다. 따라서 작업은 계약의 실제 동작을 지정하고 정의합니다. 계정 생성, 생산자 투표, 토큰 운영 등을 위한 표준 EOS 계약에서 여러 작업이 구현됩니다. 애플리케이션 개발자는 자신의 스마트 계약 및 애플리케이션 내에서 사용자 지정 작업을 생성하여 이 기능을 모두 확장, 교체 또는 비활성화할 수 있습니다. 반면 트랜잭션은 일반적으로 애플리케이션 수준에서 생성됩니다. 스마트 계약은 불가지론적입니다.


#### 1.2.1. 구현

EOS 스마트 계약은 다음에서 파생되는 C++ 클래스로 구현됩니다. `eosio::contract`. 작업은 파생 클래스 내에서 C++ 메서드로 구현됩니다. 반면 트랜잭션은 EOS 애플리케이션 내에서 동적으로(트랜잭션 인스턴스로) 생성됩니다. EOS 소프트웨어는 각 트랜잭션 인스턴스를 처리하고 생성, 서명, 유효성 검사 및 실행에서 진화함에 따라 상태를 추적합니다.


## 2. 트랜잭션 인스턴스

트랜잭션 인스턴스는 트랜잭션 헤더와 실제 트랜잭션을 만드는 액션 인스턴스 및 트랜잭션 확장 목록으로 구성됩니다. 트랜잭션 헤더에는 트랜잭션이 실행을 위해 푸시될 때 계산되는 만료 시간을 기준으로 블록에 트랜잭션이 포함되었는지 평가하는 데 필요한 정보가 포함됩니다. 다른 필드에는 트랜잭션을 포함하는 블록 번호, "크로스 체인" 또는 "크로스 포크" 공격을 방지하는 데 사용되는 블록 ID 접두사, CPU 및 네트워크 사용량의 상한, 해당되는 경우 트랜잭션 지연 시간(초)이 포함됩니다. 아래 다이어그램은 트랜잭션 인스턴스를 보여줍니다.

![](../images/protocol-xacts_instance.png "Transaction Instance")

작업 인스턴스는 일반 작업 또는 컨텍스트 없는 작업으로 구성될 수 있습니다. 서명은 트랜잭션 수준에서 생성되고 검증됩니다. 계정 및 권한은 작업별로 처리됩니다. 각 작업 인스턴스에는 해당 작업에 지정된 행위자의 권한 수준과 해당 작업에 대한 스마트 계약에 정의된 실제 권한에 따라 실행할 권한이 있는지 여부를 확인하는 정보가 포함되어 있습니다(참조: [3.4.2. 권한 확인](#342-permission-check)).


### 2.1. 트랜잭션 ID

트랜잭션 인스턴스에는 하나의 트랜잭션을 다른 트랜잭션과 구별하는 최소 필드 집합이 포함되어 있습니다. 결과적으로 트랜잭션 ID는 트랜잭션 인스턴스에 포함된 기본 필드의 암호화 해시로 구성됩니다. 따라서 트랜잭션 ID는 트랜잭션 내에 캡슐화된 작업 목록, 트랜잭션 헤더 및 선택적 내장 트랜잭션 확장에 의해서만 결정됩니다. 트랜잭션 인스턴스는 서명된 트랜잭션 인스턴스 또는 압축된 트랜잭션 인스턴스로 더 전문화될 수 있습니다.


### 2.2. 서명된 트랜잭션 인스턴스

서명된 트랜잭션은 트랜잭션에 서명한 계정에서 생성된 서명을 포함하도록 트랜잭션 스키마의 기본 내용을 확장합니다. 또한 트랜잭션 인스턴스에 포함된 컨텍스트 없는 작업(있는 경우)과 관련된 데이터도 포함합니다(참조: `signed_transaction` 아래 스키마). 트랜잭션은 해당 행위자가 서명하지 않으면 실행 및 검증 준비가 되지 않습니다.

#### signed_transaction 스키마

이름 | 유형 | 설명
-|-|-
`expiration` | `time_point_sec` | 거래가 만료되기 전에 확인되어야 하는 시간
`ref_block_num` | `uint16_t` | 마지막 $2^{16}$ 블록에서 블록 번호의 하위 16비트
`ref_block_prefix` | `uint32_t` | 에서 참조하는 블록 ID의 하위 32비트 ref_block_num'
`max_net_usage_words` | `unsigned_int` | 청구되는 총 네트워크 대역폭의 상한선(64비트 단어)
`max_cpu_usage_ms` | `uint8_t` | 청구되는 총 CPU 시간의 상한(밀리초)
`delay_sec` | `unsigned_int` | 트랜잭션 지연 시간(초)
`context_free_actions` | 의 배열 `action` | 컨텍스트 없는 작업 목록(있는 경우)
`actions` | 의 배열 `action` | 목록 [액션 인스턴스](#343-action-instance)
`transaction_extensions` | `extensions_type` | 추가 기능을 지원하도록 필드 확장
`signatures` | 의 배열 `signature_type` | 거래 서명 후 디지털 서명
`context_free_data` | 의 배열 `bytes` | 있는 경우 보낼 컨텍스트 프리 액션 데이터


### 2.3. 묶음 트랜잭션 인스턴스

압축된 트랜잭션은 압축 해제 및 빠른 유효성 검사를 허용하는 추가 하우스키핑 필드가 있는 선택적으로 압축된 서명된 트랜잭션입니다. 압축된 트랜잭션은 장기적으로 공간 풋프린트와 블록 크기를 최소화합니다(참조: `packed_transaction` 아래 스키마). 압축 트랜잭션은 EOS 블록체인에서 가장 일반적인 유형의 트랜잭션을 형성합니다. 결과적으로 트랜잭션이 블록으로 푸시되면 압축 여부에 관계없이 실제로 압축된 트랜잭션입니다.

####packed_transaction 스키마

이름 | 유형 | 설명
-|-|-
`signatures` | `signature_type` | 거래 서명 후 디지털 서명
`compression` | `compression_type` | 사용된 압축 방법
`packed_context_free_data` | `bytes` | 압축된 컨텍스트 프리 데이터(트랜잭션이 압축된 경우)
`packed_trx` | `bytes` | 압축된 트랜잭션(압축된 경우)
`unpacked_trx` | `signed_transaction` | 캐시된 압축 해제 트랜잭션
`trx_id` | `transaction_id_type` | 트랜잭션 ID

그만큼 `unpacked_trx` 필드는 트랜잭션 인스턴스가 생성된 후 캐시된 압축 해제된 트랜잭션을 보유합니다. 서명된 트랜잭션이 이전에 압축된 경우 `packed_trx` 필드 및 캐시됨 `unpacked_trx`. 서명된 트랜잭션이 압축되지 않은 상태로 저장된 경우 간단히 그대로 복사됩니다. `unpacked_trx`. 그만큼 `signatures` 필드를 사용하면 트랜잭션의 전체 압축을 풀 필요 없이 트랜잭션의 빠른 서명 검증이 가능합니다.


## 3. 트랜잭션 수명 주기

트랜잭션은 수명 동안 다양한 단계를 거칩니다. 먼저 트랜잭션에 관련 작업을 푸시하여 응용 프로그램 또는 cleos와 같은 EOS 클라이언트에서 트랜잭션이 생성됩니다. 다음으로 트랜잭션은 로컬로 연결된 노드로 전송되며, P2P 네트워크를 통해 검증 및 실행을 위해 활성 생성 노드로 전달됩니다. 다음으로 검증된 거래는 활성 생산자에 의해 일정에 따라 다른 거래와 함께 블록으로 푸시됩니다. 마지막으로 트랜잭션이 포함된 블록은 유효성 검사를 위해 다른 모든 노드로 푸시됩니다. 대다수의 생산자가 블록을 검증하고 블록을 되돌릴 수 없게 되면 트랜잭션이 블록체인에 영구적으로 기록되고 변경할 수 없는 것으로 간주됩니다.


### 3.1. 거래 생성

트랜잭션은 트랜잭션 개체를 인스턴스화하고 관련 작업 인스턴스를 트랜잭션 인스턴스 내의 목록으로 푸시하여 애플리케이션 내에서 생성됩니다. 작업 인스턴스에는 작업이 의도된 수신자 계정에 대한 실제 세부 정보, 작업 이름, 서명 및 지연을 통해 트랜잭션을 승인해야 하는 행위자 및 권한 수준 목록, 보낼 실제 메시지가 포함됩니다. 아무거나(참조 `action` 아래 스키마).

#### 액션 스키마

이름 | 유형 | 설명
-|-|-
`account` | `name` | 인코딩된 13자리 계정 이름
`action_name` | `name` | 인코딩된 13자 작업 이름
`authorization` | 의 배열 `permission_level` | 목록 `actor:permission` 승인
`data` | `bytes` | 보낼 액션 데이터

트랜잭션 인스턴스가 응용 프로그램 수준에서 생성된 후 처리를 위해 트랜잭션이 정렬됩니다. 여기에는 트랜잭션에 서명하고 트랜잭션의 실제 전파 및 실행을 위해 서명된 트랜잭션을 로컬 노드로 푸시하는 두 가지 주요 단계가 포함됩니다. 이러한 단계는 일반적으로 EOS 애플리케이션 내에서 수행됩니다.


### 3.2. 트랜잭션 서명

트랜잭션은 누적된 명시적 키 세트를 만족시키기에 충분한 키 세트로 서명되어야 합니다. `actor:permission` 트랜잭션 내에 포함된 모든 작업에 지정된 쌍. 이 연결은 주어진 권한에 대한 권한 테이블을 통해 이루어집니다. 실제 서명 키는 애플리케이션이 실행되는 클라이언트의 서명 계정과 연결된 지갑을 쿼리하여 얻습니다.

트랜잭션 서명 프로세스는 세 가지 매개변수를 사용합니다. 서명할 트랜잭션 인스턴스, 애플리케이션 지갑 내에서 관련 개인 키를 검색하는 공개 키 세트 및 체인 ID입니다. 체인 ID는 실제 EOS 블록체인을 식별하고 블록체인의 초기 구성 매개변수에 따라 생성 상태의 해시로 구성됩니다. 트랜잭션에 서명하기 전에 EOS 소프트웨어는 먼저 트랜잭션의 다이제스트를 계산합니다. 다이제스트 값은 체인 ID의 SHA-256 해시, 트랜잭션 인스턴스 및 트랜잭션에 컨텍스트 없는 작업이 있는 경우 컨텍스트 없는 데이터입니다. 모든 인스턴스 필드는 해시 계산에 참조 필드(메모리 주소)를 포함하지 않도록 암호화 해시를 계산하기 전에 직렬화됩니다. 트랜잭션 다이제스트 계산 및 서명 프로세스는 아래에 설명되어 있습니다.

![](../images/protocol-xact_sign.png "Transaction Signing")

트랜잭션 다이제스트가 계산된 후 다이제스트는 최종적으로 서명 계정의 공개 키와 연결된 개인 키로 서명됩니다. 공개-개인 키 쌍은 일반적으로 로컬 노드에 연결되는 로컬 시스템 내에 저장됩니다. 서명 프로세스는 일반적으로 애플리케이션을 배포하는 동일한 사용자인 서명 계정과 연결된 지갑 관리자 내에서 수행됩니다. 지갑 관리자는 디지털 서명을 수행하기 위한 가상 보안 영역을 제공하므로 개인 키가 지갑을 떠나지 않고 메시지 서명이 생성됩니다. 서명이 생성된 후 최종적으로 서명된 트랜잭션 인스턴스에 추가됩니다.


### 3.3. 트랜잭션 푸시

트랜잭션이 서명된 후 서명된 트랜잭션 인스턴스에서 압축된 트랜잭션 인스턴스가 생성되고 애플리케이션에서 로컬 노드로 푸시되며, 그러면 트랜잭션이 서명 확인, 실행 및 유효성 검사를 위해 활성 생성 노드로 전달됩니다. 트랜잭션을 수신하는 모든 생성 노드는 트랜잭션을 다음 생성 노드로 전달하기 전에 로컬 컨텍스트에서 실행 및 유효성 검사를 시도합니다. 따라서 유효한 트랜잭션은 릴레이되고 유효하지 않은 트랜잭션은 삭제됩니다. 이것의 이면에 있는 아이디어는 나쁜 행위자가 가짜 트랜잭션으로 네트워크에 스팸을 보내는 것을 방지하는 것입니다. 일정에 따라 활성 생산자에 도달하기 전에 잘못된 트랜잭션이 필터링되고 삭제될 것으로 예상됩니다. 거래가 수신되면 그 유효성에 대한 가정이 이루어지지 않습니다. 모든 거래는 블록 생산 여부에 관계없이 다음 생산 노드에서 다시 검증됩니다. 유일한 차이점은 일정에 따라 생산자가 확정된 블록을 자체 로컬 체인으로 푸시하고 다른 노드로 전달하기 전에 검증된 트랜잭션을 보류 중인 블록으로 푸시하여 블록 생성을 시도한다는 것입니다.


### 3.4. 거래 확인

트랜잭션을 확인하는 프로세스는 두 가지입니다. 첫째, 거래에 서명한 계정과 관련된 공개 키는 거래에서 제공된 서명 집합에서 복구됩니다. 이러한 복구는 EOS에서 사용되는 타원 곡선 디지털 서명 알고리즘인 ECDSA에 대해 암호학적으로 가능합니다. 둘째, 트랜잭션에 포함된 각 작업의 작업 승인 목록(actor:permission)에 지정된 각 행위자의 공개 키를 복구된 키 집합과 비교하여 만족하는지 확인합니다. 셋째, 각각 만족 `actor:permission` 해당 작업에 필요한 관련 최소 권한에 대해 확인됩니다. `actor:contract::action` 최소값을 충족하거나 초과하는지 확인하기 위해 쌍을 이룹니다. 이 마지막 확인은 작업이 실행되기 전에 작업 수준에서 수행됩니다(참조: [3.4.2. 권한 확인](#342-permission-check)).


#### 3.4.1. 트랜잭션 컨텍스트

공개 키가 복구되면 트랜잭션 인스턴스에서 트랜잭션 컨텍스트가 생성됩니다. 트랜잭션 컨텍스트는 각 액션이 발송되고 실행될 때 생성된 액션 영수증과 액션 추적을 추적합니다. 생성된 모든 상태는 트랜잭션 추적 인스턴스와 작업 영수증 목록에 보관됩니다. 트랜잭션 추적은 작업 추적 목록으로 구성됩니다. 각 작업 추적에는 실행된 작업에 대한 정보가 포함되며 여기에는 작업 수신, 작업 인스턴스, 컨텍스트 없는 작업인지 여부 및 작업을 생성한 트랜잭션 ID가 포함됩니다. 작업 영수증은 나중에 트랜잭션 실행 및 완료 중에 생성됩니다.


#### 3.4.2. 권한 확인

트랜잭션에 포함된 일련의 작업은 전체적으로 원자적으로 실행되어야 하므로 EOS 소프트웨어는 먼저 각 작업에 지정된 액터가 실행에 필요한 최소 권한을 가지고 있는지 확인합니다. 이를 위해 소프트웨어는 각 작업에 대해 다음을 확인합니다.

* 각 작업 인스턴스에 지정된 각 액터의 명명된 권한입니다.
* 해당 권한의 명명된 권한 `actor:contract::action` 스마트 계약에 지정된 쌍.

명명된 권한 집합이 해당 권한에서 요구하는 최소 권한 수준을 충족하지 못하는 행위자가 하나 이상 있는 경우 `actor:contract::action` 스마트 계약에서 쌍을 이루면 트랜잭션이 실패합니다. 액션이 실행되기 전에 액션 권한을 확인하는 이유는 성능 때문입니다. 모든 작업이 실행되지 않은 상태에서 트랜잭션을 취소하는 것이 몇 가지 작업이 실행된 후 취소하는 것보다 더 효율적이지만 나중에 작업 또는 권한 부여 실패의 결과로 롤백되었습니다. 실패한 작업 중에 발생한 모든 상태 변경은 데이터 무결성을 유지하기 위해 실행 취소해야 합니다. 데이터베이스 세션은 메모리 사용 및 컴퓨팅 리소스 측면에서 비용이 많이 듭니다. 따라서 실행 취소 작업은 가능한 한 최소화해야 합니다.


#### 3.4.3. 액션 인스턴스

아래 다이어그램은 작업 인스턴스를 보여줍니다. 수신자 계정, 작업 이름, 행위자 목록 및 해당 권한, 수신자 계정으로 보낼 메시지가 포함된 작업 데이터(있는 경우)로 구성됩니다.

![](../images/protocol-xacts_act_instance.png "Action Instance")

#### 3.4.4. 권한 확인

최소 권한 레벨을 확인한 후 action 인스턴스 내 각 행위자의 권한과 일치하는 수신자 계정의 권한에 대한 권한 테이블을 확인합니다.


### 3.5. 트랜잭션 실행

트랜잭션을 실행하기 위해 체인 데이터베이스 세션이 시작되고 스냅샷이 생성됩니다. 이를 통해 트랜잭션 작업이 실패하는 경우 체인 상태에 대한 모든 변경 사항을 롤백할 수 있습니다. 해당 트랜잭션 컨텍스트는 실행 중에 트랜잭션 상태를 유지합니다. 트랜잭션을 실행하기 위해 해당 트랜잭션 인스턴스와 관련된 각 작업이 실행을 위해 디스패치됩니다. 컨텍스트 프리 액션(있는 경우)이 먼저 디스패치된 다음 일반 액션이 디스패치됩니다.


#### 3.5.1. 컨텍스트 적용

작업 실행을 준비하기 위해 각 작업에 대해 컨텍스트 적용 인스턴스가 로컬로 생성됩니다. 적용 컨텍스트는 이름에서 알 수 있듯이 체인 컨트롤러에 대한 인스턴스와 같이 작업을 적용하는 데 필요한 리소스에 대한 참조를 포함합니다(참조: [네트워크 피어 프로토콜: 2.2. 체인 컨트롤러](03_network-peer-protocol.md#22-chain-controller)), 상태가 유지되는 체인 데이터베이스, 트랜잭션이 실행 중인 트랜잭션 컨텍스트, 실제 작업 인스턴스 및 작업이 의도된 수신자 계정.


#### 3.5.2. 액션 트레이스

실행을 위해 각 작업을 준비하기 위해 작업 수신 및 작업 추적 인스턴스가 모두 초기화됩니다. 먼저 액션 인스턴스 자체의 해시가 계산되어 액션 영수증에 저장됩니다. 다음으로, 조치를 포함하는 트랜잭션이 푸시될 보류 중인 블록에 대한 통계로 조치 추적이 초기화됩니다. 따라서 액션 추적을 통해 블록을 생성한 실제 노드를 포함하여 액션을 포함하는 실제 블록 및 트랜잭션까지 액션을 추적할 수 있습니다. 마지막으로 생산 노드 내에서 체인 컨트롤러가 유지 관리하는 작업 핸들러 목록과 핸들러 이름, 수신자 계정 및 행위자 계정을 일치시켜 작업 핸들러를 찾습니다. 이러한 작업 핸들러는 시스템 계약 및 클라이언트 애플리케이션이 로드될 때 컨트롤러에 적용됩니다. 처리기는 수신자 계정 이름, 계약 이름, 작업 이름 및 작업 처리기를 사용합니다.


#### 3.5.3. 액션 실행

적절한 작업 핸들러를 찾으면 적절한 화이트리스트와 블랙리스트가 확인됩니다. 노드가 현재 블록을 생성하고 있는 경우 수신자 계정을 계정 화이트리스트 및 블랙리스트(있는 경우)와 비교하여 확인합니다. 작업 블랙리스트가 있으면 다음으로 확인합니다. 수신자 계정 또는 작업 이름이 블랙리스트에 있는 경우 작업이 중단됩니다. 수신자 계정이 이미 화이트리스트에 있는 경우 블랙리스트 확인을 건너뜁니다. 모든 검사가 통과되면 해당 액션 핸들러를 호출하고 행위자 계정을 `from` 매개변수 및 수신 계정 `to` 매개변수.


### 3.6. 거래 마무리

트랜잭션에 포함된 모든 작업이 실행된 후 트랜잭션은 완료 단계에 들어갑니다. 이 단계에서는 각 작업에 대해 해당 작업 영수증이 생성됩니다. 작업 수신에는 해당 작업 인스턴스의 해시, 분석에 사용되는 몇 가지 카운터 및 해당하는 경우 작업이 의도된 수신자 계정이 포함됩니다.


#### 3.6.1. 거래 영수증

트랜잭션에 대한 모든 작업 영수증이 생성된 후 트랜잭션 영수증이 최종적으로 생성되어 블록에 포함된 다른 트랜잭션 영수증과 함께 서명된 블록으로 푸시됩니다. 트랜잭션 수신에는 마이크로초 단위로 청구되는 실제 CPU 양과 사용된 총 NET 스토리지를 포함하여 트랜잭션 결과(실행됨, 실행되지 않음, 실패, 연기됨, 만료됨 등)가 요약됩니다(참조: `transaction_receipt` 아래 스키마).

##### transaction_receipt 스키마

이름 | 유형 | 설명
-|-|-
`status` | `uint8_t` | 트랜잭션 실행 시도 결과
`cpu_usage_us` | `uint32_t` | 사용된 총 CPU(마이크로초)
`net_usage_words` | `unsigned int` | 64비트 워드에서 사용된 총 NET
`trx` | `variant` | 거래 ID 또는 묶음 거래 보유

그만큼 `status` field는 다음 결과 중 하나를 보유할 수 있는 8비트 열거 유형입니다.

* `executed` - 트랜잭션이 성공했으며 오류 처리기가 실행되지 않았습니다.
* `soft_fail` - 트랜잭션 실패, 오류 처리기 성공.
* `hard_fail` - 트랜잭션 실패, 오류 처리기 실패.
* `delayed` - 향후 실행을 위해 사용자가 지연한 트랜잭션.
* `expired` - 트랜잭션 만료, CPU/NET이 사용자에게 환불됨.

[[정보 | '지연' 상태]]
| 그만큼 `delayed` 상태는 **지연된 사용자 트랜잭션**, 즉 승인을 충족하기 위해 지연이 있는 명시적인 사용자 생성 트랜잭션에만 적용됩니다(참조 [3.6.3. 지연된 사용자 거래](#363-delayed-user-transactions) 자세한 내용은).

그만큼 `trx` 필드는 트랜잭션 ID 또는 압축된 트랜잭션 자체를 보유합니다. 실제 선택은 트랜잭션 유형에 따라 다릅니다. 지연된 트랜잭션 및 지연된 사용자 트랜잭션에서 생성된 영수증은 트랜잭션 ID로 저장됩니다. 다른 모든 유형은 압축된 트랜잭션으로 저장됩니다.


#### 3.6.2. 지연된 트랜잭션

유예 트랜잭션은 블록체인 처리의 부작용으로 발생하므로 해당 상태는 블록이 아닌 체인 데이터베이스에 저장됩니다. 따라서 트랜잭션 영수증에 해당 내용을 명시적으로 포함할 필요가 없습니다. 모든 in-sync 노드는 합의의 문제로 지연된 트랜잭션의 형태를 인식해야 합니다. 스마트 계약에 의해 발행된 지연된 트랜잭션은 `delayed` 거래 영수증의 상태 필드.

[[주의 | 지원 중단 알림]]
| 지연된 트랜잭션은 EOS 2.0부터 더 이상 사용되지 않습니다.

#### 3.6.3. 지연된 사용자 거래

지연된 사용자 트랜잭션에는 네트워크에 푸시될 때(지연 타이머 시작 시) 압축된 트랜잭션이 포함됩니다. 그러나 일반 트랜잭션과 달리 "지연" 상태이므로 실행 및 유효성 검사를 연기할 수 있습니다. 나중에 실행/실패/만료될 때(지연 타이머가 끝날 때) 트랜잭션 ID만 포함됩니다. 동기화된 모든 노드가 이전에 브로드캐스트된 블록의 트랜잭션 내용을 갖기 때문입니다.


### 3.7. 거래 확인

트랜잭션은 수명 주기 동안 다양한 단계에서 확인 및 검증됩니다. 먼저 P2P 네트워크에서 느슨한 트랜잭션으로 전파될 때(참조: [3.4. 거래 확인](#34-verify-transaction)) 그런 다음 블록 유효성 검사 중에 대다수의 블록 생산자 사이에서 블록이 확인되고 선택적으로 nodeos가 재생 중에 트랜잭션을 완전히 재검증하도록 구성된 경우 블록체인 재생 중에 선택적으로 수행됩니다. 기본적으로 기록된 트랜잭션은 노드 운영자가 개인적으로 또는 사이드 채널을 통해 로컬 블록 로그에 대한 신뢰를 설정하여 더 이상 비잔틴 정보의 잠재적 소스로 간주되지 않기 때문에 재생 중에 완전히 재검증되지 않습니다. .


#### 3.7.1. 검증 프로세스

트랜잭션을 블록의 일부로 검증할 때 다양한 수준에서 여러 검증이 발생합니다. 전체 블록 유효성 검사에서는 블록에 기록된 모든 트랜잭션이 재생되고 로컬에서 계산된 머클 트리 루트 해시(각각 트랜잭션 수신 데이터 및 작업 수신 데이터에서 생성됨)가 블록과 비교됩니다. `transaction_mroot` 그리고 `action_mroot` 블록 헤더의 필드. 따라서 기록된 트랜잭션이 블록 내에서 변조되면 머클 트리 루트 해시가 불일치할 뿐만 아니라 트랜잭션 서명도 유효성 검사에 실패합니다. 변조가 선의의 블록 생산자에 의해 수행되지 않은 경우 블록 서명도 유효성을 검사하지 못할 것입니다(참조: [합의 프로토콜: 5.3. 블록 유효성 검사](01_consensus-protocol.md#53-block-validation)).
