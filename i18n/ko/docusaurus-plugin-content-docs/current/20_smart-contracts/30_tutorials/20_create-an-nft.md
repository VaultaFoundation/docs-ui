---
title: NFT ìƒì„±
---

NFTëŠ” **ëŒ€ì²´ ë¶ˆê°€ëŠ¥í•œ í† í°**ì…ë‹ˆë‹¤. ì´ëŠ” ê³ ìœ í•œ í† í°ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.
ë‹¤ë¥¸ í† í°ìœ¼ë¡œ êµí™˜ë©ë‹ˆë‹¤.

ìˆ˜ì§‘ ê°€ëŠ¥í•œ í•­ëª©(ìœ ëª…ì¸ì´ ì†Œìœ í•œ íœ, ê²Œì„ ìš°ìŠ¹ ê³µ ë“±)ì„ ì˜ˆë¡œ ë“¤ì–´ ë³´ê² ìŠµë‹ˆë‹¤. ì´ë“¤ ê°ê°
í•­ëª©ì€ ê³ ìœ í•˜ë©° ê°’ì´ ë‹¤ë¥´ê¸° ë•Œë¬¸ì— ë‹¤ë¥¸ í•­ëª©ê³¼ êµí™˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
ê·¸ë“¤ì˜ ë…ì°½ì„±.

> ğŸ‘€ **NFTë¥¼ ìƒì„±í•˜ê³  ì‹¶ìœ¼ì‹ ê°€ìš”?**
>
> ì´ íŠœí† ë¦¬ì–¼ì—ì„œëŠ” Ethereumì˜ ERC721ì„ ë”°ë¥´ëŠ” NFT ìƒì„±ì— ëŒ€í•´ ë…¼ì˜í•  ê²ƒì…ë‹ˆë‹¤.
> í‘œì¤€ì„ ì‚¬ìš©í•˜ì—¬ ëª…í™•í•œ í‘œì¤€ì„ ì‚¬ìš©í•˜ì—¬ ì¼ë¶€ EOS ê°œë°œì„ íŒŒí—¤ì¹  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
>
> **ë‹¨**, NFTë¥¼ ìƒì„±í•˜ë ¤ëŠ” ê²½ìš° [**ì›ì ìì‚°**](https://github.com/pinknetworkx/atomicassets-contract) í‘œì¤€
> EOS ë„¤íŠ¸ì›Œí¬ì—ì„œ ë” ì¼ë°˜ì ì…ë‹ˆë‹¤. [ì•„í† ë¯¹ ìì‚° NFT ìƒì„±ê¸°](https://eos.atomichub.io/creator)
> ì½”ë“œë¥¼ ë°°í¬í•˜ì§€ ì•Šê³  AtomicHub ì‹œì¥ì— ì¦‰ì‹œ ë‚˜ì—´ë˜ëŠ” NFTë¥¼ ì‰½ê²Œ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## NFT í‘œì¤€ì´ë€ ë¬´ì—‡ì…ë‹ˆê¹Œ?

NFT í‘œì¤€ì€ ëª¨ë“  NFTê°€ ë”°ë¼ì•¼ í•˜ëŠ” ì¼ë ¨ì˜ ê·œì¹™ì…ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ NFTëŠ”
ë‹¤ë¥¸ NFTì™€ ìƒí˜¸ ìš´ìš© ê°€ëŠ¥í•˜ë©° ë§ˆì¼“í”Œë ˆì´ìŠ¤ ë° ì§€ê°‘ê³¼ ê°™ì€ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ
ê·¸ë“¤ê³¼ ìƒí˜¸ ì‘ìš©í•˜ëŠ” ë°©ë²•ì„ ì´í•´í•˜ì‹­ì‹œì˜¤.

## ERC721 í‘œì¤€ì´ ë¬´ì—‡ì¸ê°€ìš”?

ê·¸ë§Œí¼ [ERC721 í‘œì¤€](https://eips.ethereum.org/EIPS/eip-721) Ethereum ì»¤ë®¤ë‹ˆí‹°ì—ì„œ ë§Œë“  NFT í‘œì¤€ì…ë‹ˆë‹¤. ê·¸ê²ƒ
ê°€ì¥ ì¼ë°˜ì ì¸ NFT í‘œì¤€ì´ë©° Ethereum ë„¤íŠ¸ì›Œí¬ì˜ ë§ì€ NFTì—ì„œ ì‚¬ìš©ë©ë‹ˆë‹¤. ë§Œì•½ ë‹¹ì‹ ì´
Bored Apeë¥¼ ë³¸ ì ì´ ìˆë‹¤ë©´ ERC721 NFTì…ë‹ˆë‹¤.

![ì§€ë£¨í•œ ìœ ì¸ì› í´ëŸ½ ì˜ˆ](./images/boredapeclub.jpg)

## ê°œë°œ í™˜ê²½

ë‹¹ì‹ ì´ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸ [ëª¨ë˜ ì–¸ë•](../../20_smart-contracts/10_getting-started/10_dune-guide.md) ì„¤ì¹˜ëœ
ê³„ì•½ì„ ì²´ê²°í•˜ëŠ” ë°©ë²•ì„ ì´í•´í•©ë‹ˆë‹¤.

ê° ë‹¨ê³„ê°€ ëë‚˜ë©´ ê³„ì•½ì„ ì»´íŒŒì¼í•˜ê³  ì˜¤ë¥˜ê°€ ìˆëŠ”ì§€ í™•ì¸í•´ì•¼ í•©ë‹ˆë‹¤.

## ìƒˆ ê³„ì•½ ë§Œë“¤ê¸°

ìƒˆë¡œ ë§Œë“¤ê¸° `nft.cpp` íŒŒì¼ì„ ë§Œë“¤ê³  ë‹¤ìŒ ì½”ë“œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

```cpp
#include <eosio/eosio.hpp>
#include <eosio/asset.hpp>
#include <eosio/singleton.hpp>
using namespace eosio;

CONTRACT nft : public contract {

    public:
    using contract::contract;
    
    // TODO: Add actions
};
```

## ì•¡ì…˜ ë§Œë“¤ê¸°

ìš°ë¦¬ê°€ ë³´ë©´ [ERC721 í‘œì¤€](https://eips.ethereum.org/EIPS/eip-721), ìš°ë¦¬ëŠ” ê·¸ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤
êµ¬í˜„í•´ì•¼ í•  ëª‡ ê°€ì§€ ì‘ì—…ì´ ìˆìŠµë‹ˆë‹¤. ì „ë°˜ì ìœ¼ë¡œ í‘œì¤€ì€ ë§¤ìš° ê°„ë‹¨í•˜ì§€ë§Œ
ì¼ë¶€ ê°œë…ì€ ë°˜ë“œì‹œ EOS ë„¤ì´í‹°ë¸Œê°€ ì•„ë‹™ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ê°œë…ì´ ì—†ìŠµë‹ˆë‹¤.
~ì˜ `approvals` ë‹¤ë¥¸ ê³„ì •ìœ¼ë¡œ ì§ì ‘ í† í°ì„ ë³´ë‚¼ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— EOSì—ì„œ(í†µí•´ `on_notify` ì´ë²¤íŠ¸), ì´ë”ë¦¬ì›€ê³¼ëŠ” ë‹¤ë¦…ë‹ˆë‹¤.

ê°€ëŠ¥í•œ í•œ ì›ë³¸ì— ê°€ê¹Œìš´ í‘œì¤€ì„ ìœ ì§€í•˜ê¸° ìœ„í•´ ìš°ë¦¬ëŠ” êµ¬í˜„í•  ê²ƒì…ë‹ˆë‹¤.
ì´ ììŠµì„œì˜ ê¸°ë³¸ì´ ì•„ë‹Œ ê°œë….

ìš°ë¦¬ê°€ ì‹œí–‰í•  ì¡°ì¹˜ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

```cpp
    ACTION mint(name to, uint64_t token_id){
    
    }
    
    ACTION transfer(name from, name to, uint64_t token_id, std::string memo){
    
    }
    
    [[eosio::action]] uint64_t balanceof(name owner){
    
    }
    
    [[eosio::action]] name ownerof(uint64_t token_id){
    
    }
    
    ACTION approve(name to, uint64_t token_id){
    
    }
    
    ACTION approveall(name from, name to, bool approved){
    
    }
    
    [[eosio::action]] name getapproved(uint64_t token_id){
    
    }
    
    [[eosio::action]] bool approved4all(name owner, name approved_account){
    
    }
    
    [[eosio::action]] std::string gettokenuri(uint64_t token_id){
    
    }
    
    ACTION setbaseuri(std::string base_uri){
    
    }
```

ì´ë¥¼ ê³„ì•½ì— ì¶”ê°€í•œ ë‹¤ìŒ ê° ì‘ì—…ì„ ìì„¸íˆ ì‚´í´ë³´ê³  ìˆ˜í–‰í•˜ëŠ” ì‘ì—…ê³¼ ìˆ˜í–‰í•˜ëŠ” ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

ë°˜í™˜ ê°’ì´ ìˆëŠ” ì‘ì—…ì´ `[[eosio::action]]` ëŒ€ì‹ ì—
~ì˜ `ACTION`.

> â” **ì•¡ì…˜ ë§¤í¬ë¡œ**
>
> `ACTION` ë¼ê³  ë¶ˆë¦¬ëŠ” ê²ƒì…ë‹ˆë‹¤ `MACRO`, ëŒ€ì²´ë  ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.
> ì»´íŒŒì¼ íƒ€ì„ì— ë‹¤ë¥¸ ì½”ë“œì™€ í•¨ê»˜. ì´ ê²½ìš°, `ACTION` ë§¤í¬ë¡œëŠ” ë‹¤ìŒìœ¼ë¡œ ëŒ€ì²´ë©ë‹ˆë‹¤.
> ```cpp
> [[eosio::action]] void
>
```
> ìš°ë¦¬ê°€ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ì´ìœ  `ACTION` ê°’ì„ ë°˜í™˜í•˜ëŠ” ì‘ì—…ì— ëŒ€í•œ ë§¤í¬ë¡œëŠ”
> ê·¸ê²ƒì€ ì¶”ê°€ `void` ì•„ë¬´ ê²ƒë„ ë°˜í™˜í•˜ì§€ ì•ŠìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

## ì•¡ì…˜ íŒŒë¼ë¯¸í„° íŒŒí—¤ì¹˜ê¸°

ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ ìì„¸í•œ ì„¤ëª…ê³¼ ê°„ë‹¨í•œ ì„¤ëª…ì„ ì›í•˜ì‹œë©´
ê° ì‘ì—…ì„ ìˆ˜í–‰í•˜ë ¤ë©´ ì•„ë˜ ì„¹ì…˜ì„ í™•ì¥í•˜ì„¸ìš”.

<ìƒì„¸>
    <summary>ë³´ë ¤ë©´ ì—¬ê¸°ë¥¼ í´ë¦­í•˜ì‹­ì‹œì˜¤</summary>

### ë¯¼íŠ¸

ê·¸ë§Œí¼ `mint` ì•¡ì…˜ì€ ìƒˆë¡œìš´ NFTë¥¼ ìƒì„±í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ë‹¤ìŒ ë‘ ê°€ì§€ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- **to** - NFTë¥¼ ì†Œìœ í•  ê³„ì •
- **token_id** - NFTì˜ ID

### ì˜®ê¸°ë‹¤

ê·¸ë§Œí¼ `transfer` ì•¡ì…˜ì€ í•œ ê³„ì •ì—ì„œ ë‹¤ë¥¸ ê³„ì •ìœ¼ë¡œ NFTë¥¼ ì „ì†¡í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ë‹¤ìŒ ë„¤ ê°€ì§€ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- **from** - í˜„ì¬ NFTë¥¼ ì†Œìœ í•˜ê³  ìˆëŠ” ê³„ì •
- **to** - NFTë¥¼ ì†Œìœ í•  ê³„ì •
- **token_id** - NFTì˜ ID
- **memo** - íŠ¸ëœì­ì…˜ì— í¬í•¨ë  ë©”ëª¨

### ë°¸ëŸ°ìŠ¤ì˜¤ë¸Œ

ê·¸ë§Œí¼ `balanceof` ì‘ì—…ì€ ê³„ì •ì˜ ì”ì•¡ì„ ê°€ì ¸ì˜¤ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

í•˜ë‚˜ì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- **ì†Œìœ ì** - ì”ì•¡ì„ ë°›ìœ¼ë ¤ëŠ” ê³„ì •

ê·¸ê²ƒì€ `uint64_t` ê³„ì •ì˜ ì”ì•¡ì…ë‹ˆë‹¤.

### ì†Œìœ ì

ê·¸ë§Œí¼ `ownerof` actionì€ NFTì˜ ì†Œìœ ìë¥¼ ì–»ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

í•˜ë‚˜ì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- **token_id** - NFTì˜ ID

ê·¸ê²ƒì€ `name` NFTë¥¼ ì†Œìœ í•œ ê³„ì •ì…ë‹ˆë‹¤.

### ìŠ¹ì¸í•˜ë‹¤

ê·¸ë§Œí¼ `approve` ì‘ì—…ì€ ê·€í•˜ë¥¼ ëŒ€ì‹ í•˜ì—¬ NFTë¥¼ ì „ì†¡í•˜ê¸° ìœ„í•´ ê³„ì •ì„ ìŠ¹ì¸í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ë‹¤ìŒ ë‘ ê°€ì§€ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- **to** - NFT ì „ì†¡ì´ ìŠ¹ì¸ë  ê³„ì •
- **token_id** - NFTì˜ ID

### ëª¨ë‘ ìŠ¹ì¸

ê·¸ë§Œí¼ `approveall` ì‘ì—…ì€ ê·€í•˜ë¥¼ ëŒ€ì‹ í•˜ì—¬ ê·€í•˜ì˜ ëª¨ë“  NFTë¥¼ ì „ì†¡í•˜ê¸° ìœ„í•´ ê³„ì •ì„ ìŠ¹ì¸í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ë‹¤ìŒ ì„¸ ê°€ì§€ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- **from** - í˜„ì¬ NFTë¥¼ ì†Œìœ í•˜ê³  ìˆëŠ” ê³„ì •
- **to** - NFT ì „ì†¡ì´ ìŠ¹ì¸ë  ê³„ì •
- **approved** - ê³„ì • ìŠ¹ì¸ ì—¬ë¶€ë¥¼ ê²°ì •í•˜ëŠ” ë¶€ìš¸

### ìŠ¹ì¸ë°›ê¸°

ê·¸ë§Œí¼ `getapproved` ì‘ì—…ì€ ê·€í•˜ë¥¼ ëŒ€ì‹ í•˜ì—¬ NFTë¥¼ ì „ì†¡í•˜ë„ë¡ ìŠ¹ì¸ëœ ê³„ì •ì„ ì–»ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

í•˜ë‚˜ì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- **token_id** - NFTì˜ ID

ê·¸ê²ƒì€ `name` NFT ì „ì†¡ì´ ìŠ¹ì¸ëœ ê³„ì •ì…ë‹ˆë‹¤.

### IsApprovedForAll

ê·¸ë§Œí¼ `approved4all` ì¡°ì¹˜ëŠ” ê³„ì •ì´ ê·€í•˜ë¥¼ ëŒ€ì‹ í•˜ì—¬ ëª¨ë“  NFTë¥¼ ì „ì†¡í•˜ë„ë¡ ìŠ¹ì¸ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ë‹¤ìŒ ë‘ ê°€ì§€ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- **ì†Œìœ ì** - í˜„ì¬ NFTë¥¼ ì†Œìœ í•˜ê³  ìˆëŠ” ê³„ì •
- **approved_account** - NFT ì „ì†¡ ìŠ¹ì¸ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ë ¤ëŠ” ê³„ì •

ê·¸ê²ƒì€ `bool` ê·¸ê²ƒì€ `true` ê³„ì •ì´ NFTë¥¼ ì „ì†¡í•˜ë„ë¡ ìŠ¹ì¸ëœ ê²½ìš° `false` ê·¸ë ‡ì§€ ì•Šì€ ê²½ìš°.

### í† í°URI

ê·¸ë§Œí¼ `gettokenuri` actionì€ NFT ë©”íƒ€ë°ì´í„°ì˜ URIë¥¼ ê°€ì ¸ì˜¤ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

í•˜ë‚˜ì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- **token_id** - NFTì˜ ID

ê·¸ê²ƒì€ `std::string` NFT ë©”íƒ€ë°ì´í„°ì˜ URIì…ë‹ˆë‹¤.

### SetBaseURI

ê·¸ë§Œí¼ `setbaseuri` actionì€ NFT ë©”íƒ€ë°ì´í„°ì˜ ê¸°ë³¸ URIë¥¼ ì„¤ì •í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

í•˜ë‚˜ì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- **base_uri** - NFT ë©”íƒ€ë°ì´í„°ì˜ ê¸°ë³¸ URI
    
</ì„¸ë¶€ ì‚¬í•­>


## ë°ì´í„° êµ¬ì¡° ì¶”ê°€

ì´ì œ ì‘ì—…ì„ ìˆ˜í–‰í–ˆìœ¼ë¯€ë¡œ NFTë¥¼ ì €ì¥í•˜ê¸° ìœ„í•´ ì¼ë¶€ ë°ì´í„° êµ¬ì¡°ë¥¼ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤.

ìš°ë¦¬ëŠ” `singleton` NFTë¥¼ ì €ì¥í•©ë‹ˆë‹¤.

> â” **ì‹±ê¸€í†¤**
>
> ì—ì´ `singleton` í…Œì´ë¸”ê³¼ ë‹¬ë¦¬ ë²”ìœ„ë‹¹ í•˜ë‚˜ì˜ í–‰ë§Œ ê°€ì§ˆ ìˆ˜ ìˆëŠ” í…Œì´ë¸”ì…ë‹ˆë‹¤. `multi_index` ì–´ëŠ
> ë²”ìœ„ë‹¹ ì—¬ëŸ¬ í–‰ì„ ê°€ì§ˆ ìˆ˜ ìˆìœ¼ë©° `primary_key` ê° í–‰ì„ ì‹ë³„í•©ë‹ˆë‹¤.
> ì‹±ê¸€í†¤ì€ ì´ë”ë¦¬ì›€ì˜ ìŠ¤í† ë¦¬ì§€ ëª¨ë¸ì— ì¡°ê¸ˆ ë” ê°€ê¹ìŠµë‹ˆë‹¤.

ì‘ì—… ìœ„ì˜ ê³„ì•½ì— ë‹¤ìŒ ì½”ë“œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

```cpp
    using _owners = singleton<"owners"_n, name>;
    using _balances = singleton<"balances"_n, uint64_t>;
    using _approvals = singleton<"approvals"_n, name>;
    using _approvealls = singleton<"approvealls"_n, name>;
    using _base_uris = singleton<"baseuris"_n, std::string>;
    
    ACTION mint...
```

ë‹¤ìŒì— ëŒ€í•œ ì‹±ê¸€í†¤ í…Œì´ë¸”ì„ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.
- **_owners** - í† í° IDì—ì„œ NFT ì†Œìœ ìë¡œì˜ ë§¤í•‘
- **_balances** - ì†Œìœ ì£¼ì—ì„œ ì†Œìœ í•œ NFT ê¸ˆì•¡ìœ¼ë¡œì˜ ë§¤í•‘
- **_approvals** - í† í° IDì—ì„œ í•´ë‹¹ NFTë¥¼ ì „ì†¡í•˜ë„ë¡ ìŠ¹ì¸ëœ ê³„ì •ìœ¼ë¡œì˜ ë§¤í•‘
- **_approvealls** - ì†Œìœ ìì—ì„œ ëª¨ë“  NFTë¥¼ ì „ì†¡í•˜ë„ë¡ ìŠ¹ì¸ëœ ê³„ì •ìœ¼ë¡œì˜ ë§¤í•‘
- **_base_uris** - NFT ë©”íƒ€ë°ì´í„°ì˜ ê¸°ë³¸ URIë¥¼ ì €ì¥í•˜ëŠ” êµ¬ì„± í…Œì´ë¸”

> â” **í…Œì´ë¸” ì´ë¦„ ì§€ì •**
>
> `singleton<"<TABLE NAME>"_n, <ROW TYPE>>`
>
> ì‹±ê¸€í†¤ ì •ì˜ë¥¼ ë³´ë©´ í°ë”°ì˜´í‘œ ì•ˆì— í…Œì´ë¸” ì´ë¦„ì´ ìˆìŠµë‹ˆë‹¤.
> EOS í…Œì´ë¸”ì˜ ì´ë¦„ë„ ê³„ì • ì´ë¦„ ê·œì¹™ì„ ë”°ë¼ì•¼ í•©ë‹ˆë‹¤.
> 12ì ì´í•˜ì´ë©° í•´ë‹¹ ë¬¸ìë§Œ í¬í•¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `a-z`, `1-5`, ê·¸ë¦¬ê³  `.`.

ì´ì œ NFTì— ëŒ€í•œ ë°ì´í„°ë¥¼ ì €ì¥í•  í…Œì´ë¸”ê³¼ êµ¬ì¡°ë¥¼ ë§Œë“¤ì—ˆìœ¼ë¯€ë¡œ
ê° ì‘ì—…ì— ëŒ€í•œ ë…¼ë¦¬ ì±„ìš°ê¸°ë¥¼ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


## ì¼ë¶€ ë„ìš°ë¯¸ ê¸°ëŠ¥ ì¶”ê°€

ìš°ë¦¬ëŠ” ì½”ë“œë¥¼ ë” ì½ê¸° ì‰½ê³  ì‰½ê²Œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ë„ìš°ë¯¸ í•¨ìˆ˜ë¥¼ ì›í•©ë‹ˆë‹¤.
ì‚¬ìš©. í…Œì´ë¸” ì •ì˜ ë°”ë¡œ ì•„ë˜ ê³„ì•½ì— ë‹¤ìŒ ì½”ë“œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

```cpp
    using _base_uris = singleton<"baseuris"_n, std::string>;
    
    // Helper function to get the owner of an NFT
    name get_owner(uint64_t token_id){
        
        // Note that we are using the "token_id" as the "scope" of this table.
        // This lets us use singleton tables like key-value stores, which is similar
        // to how Ethereum contracts store data.
        
        _owners owners(get_self(), token_id);
        return owners.get_or_default(name(""));
    }
    
    // Helper function to get the balance of an account
    uint64_t get_balance(name owner){
        _balances balances(get_self(), owner.value);
        return balances.get_or_default(0);
    }
    
    // Helper function to get the account that is approved to transfer an NFT on your behalf
    name get_approved(uint64_t token_id){
        _approvals approvals(get_self(), token_id);
        return approvals.get_or_default(name(""));
    }
    
    // Helper function to get the account that is approved to transfer all of your NFTs on your behalf
    name get_approved_all(name owner){
      _approvealls approvals(get_self(), owner.value);
      return approvals.get_or_default(name(""));
   }
    
    // Helper function to get the URI of the NFT's metadata
    std::string get_token_uri(uint64_t token_id){
        _base_uris base_uris(get_self(), get_self().value);
        return base_uris.get_or_default("") + "/" + std::to_string(token_id);
    }
```

ë„ìš°ë¯¸ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ì´ì „ì— ë§Œë“  í…Œì´ë¸”ì—ì„œ ë°ì´í„°ë¥¼ ë” ì‰½ê²Œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ë‹¤ìŒì— êµ¬í˜„í•  ì‘ì—…ì—ì„œ ì´ëŸ¬í•œ ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ê²ƒì…ë‹ˆë‹¤.

íŠ¹íˆ ì¼ë¶€ ê¸°ëŠ¥ì€ ì—¬ëŸ¬ ê³³ì—ì„œ ì‚¬ìš©ë˜ë¯€ë¡œ
ê·¸ë“¤ì„ ìœ„í•œ ë„ìš°ë¯¸ ê¸°ëŠ¥ì„ ë§Œë“­ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, `get_owner` ê¸°ëŠ¥ì´ ì‚¬ìš©ë©ë‹ˆë‹¤
ì—ì„œ `mint`, `transfer`, ê·¸ë¦¬ê³  `approve` í–‰ìœ„. í—¬í¼ í•¨ìˆ˜ë¥¼ â€‹â€‹ë§Œë“¤ì§€ ì•Šì•˜ë‹¤ë©´
ì´ë¥¼ ìœ„í•´ì„œëŠ” ê° ì‘ì—…ì—ì„œ ë™ì¼í•œ ì½”ë“œë¥¼ ì‘ì„±í•´ì•¼ í•©ë‹ˆë‹¤.

## ì•¡ì…˜ ì±„ìš°ê¸°

ê° ì‘ì—…ì„ ì‚´í´ë³´ê³  ì´ì— ëŒ€í•œ ë…¼ë¦¬ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤. ì„¸ì‹¬í•œ ì£¼ì˜ë¥¼ ê¸°ìš¸ì´ì‹­ì‹œì˜¤
ì£¼ì„ì€ ê° ì½”ë“œ í–‰ì˜ ê¸°ëŠ¥ì„ ì„¤ëª…í•©ë‹ˆë‹¤.

### ë¯¼íŠ¸

ê·¸ë§Œí¼ `mint` ì•¡ì…˜ì€ ìƒˆë¡œìš´ NFTë¥¼ ìƒì„±í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

```cpp
    ACTION mint(name to, uint64_t token_id){
        // We only want to mint NFTs if the action is called by the contract owner
        check(has_auth(get_self()), "only contract can mint");
        
        // The account we are minting to must exist
        check(is_account(to), "to account does not exist");
        
        // Get the owner singleton
        _owners owners(get_self(), token_id);
        
        // Check if the NFT already exists
        check(owners.get_or_default().value == 0, "NFT already exists");
        
        // Set the owner of the NFT to the account that called the action
        owners.set(to, get_self());
        
        // Get the balances table
        _balances balances(get_self(), to.value);
        
        // Set the new balances of the account
        balances.set(balances.get_or_default(0) + 1, get_self());
    }
```


### ì˜®ê¸°ë‹¤

ê·¸ë§Œí¼ `transfer` ì•¡ì…˜ì€ í•œ ê³„ì •ì—ì„œ ë‹¤ë¥¸ ê³„ì •ìœ¼ë¡œ NFTë¥¼ ì „ì†¡í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

```cpp
    ACTION transfer(name from, name to, uint64_t token_id, std::string memo){
        // The account we are transferring from must authorize this action
        check(has_auth(from), "from account has not authorized the transfer");
        
        // The account we are transferring to must exist
        check(is_account(to), "to account does not exist");
        
        // The account we are transferring from must be the owner of the NFT
        // or allowed to transfer it through an approval
        bool ownerIsFrom = get_owner(token_id) == from;
        bool fromIsApproved = get_approved(token_id) == from;
        check(ownerIsFrom || fromIsApproved, "from account is not the owner of the NFT or approved to transfer the NFT");       
        
        // Get the owner singleton
        _owners owners(get_self(), token_id);
        
        // Set the owner of the NFT to the "to" account
        owners.set(to, get_self());
        
        // Set the new balance for the "from" account
        _balances balances(get_self(), from.value);
        balances.set(balances.get_or_default(0) - 1, get_self());
        
        // Set the new balance for the "to" account
        _balances balances2(get_self(), to.value);
        balances2.set(balances2.get_or_default(0) + 1, get_self());
        
        // Remove the approval for the "from" account
        _approvals approvals(get_self(), token_id);
        approvals.remove();
        
        // Send the transfer notification
        require_recipient(from);
        require_recipient(to);
    }
```

### ë°¸ëŸ°ìŠ¤ì˜¤ë¸Œ

ê·¸ë§Œí¼ `balanceof` ì‘ì—…ì€ ê³„ì •ì˜ ì”ì•¡ì„ ê°€ì ¸ì˜¤ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

```cpp
    [[eosio::action]] uint64_t balanceof(name owner){
        return get_balance(owner);
    }
```

> âš  **ë°˜í™˜ ê°’ ë° ê²°í•© ê°€ëŠ¥ì„±**
>
> ë¦¬í„´ ê°’ì€ ë¸”ë¡ì²´ì¸ ì™¸ë¶€ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥í•˜ë©°, í˜„ì¬ ì‚¬ìš© ë¶ˆê°€
> ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ê²°í•©ì„±ì„ ìœ„í•´ EOSì—ì„œ. EOS ì§€ì› [**ì¸ë¼ì¸ ì‘ì—…**](../10_getting-started/40_smart-contract-basics.md#inline-actions) ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”
> ë‹¤ë¥¸ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì„ í˜¸ì¶œí•˜ì§€ë§Œ ê°’ì„ ë°˜í™˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

### ì†Œìœ ì

ê·¸ë§Œí¼ `ownerof` actionì€ NFTì˜ ì†Œìœ ìë¥¼ ì–»ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

```cpp
    [[eosio::action]] name ownerof(uint64_t token_id){
        return get_owner(token_id);
    }
```

### ìŠ¹ì¸í•˜ë‹¤

ê·¸ë§Œí¼ `approve` ì‘ì—…ì€ ê·€í•˜ë¥¼ ëŒ€ì‹ í•˜ì—¬ NFTë¥¼ ì „ì†¡í•˜ê¸° ìœ„í•´ ê³„ì •ì„ ìŠ¹ì¸í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

```cpp
    ACTION approve(name to, uint64_t token_id){
        // get the token owner
        name owner = get_owner(token_id);
        
        // The owner of the NFT must authorize this action
        check(has_auth(owner), "owner has not authorized the approval");
    
        // The account we are approving must exist
        check(is_account(to), "to account does not exist");
        
        // Get the approvals table
        _approvals approvals(get_self(), token_id);
        
        // Set the approval for the NFT
        approvals.set(to, get_self());
    }
```

### ëª¨ë‘ ìŠ¹ì¸

ê·¸ë§Œí¼ `approveall` ì¡°ì¹˜ëŠ” ê³„ì •ì„ ìŠ¹ì¸í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
ê·€í•˜ë¥¼ ëŒ€ì‹ í•˜ì—¬ NFT.

```cpp
    ACTION approveall(name from, name to, bool approved){
        // The owner of the NFTs must authorize this action
        check(has_auth(from), "owner has not authorized the approval");
        
        // The account we are approving must exist
        check(is_account(to), "to account does not exist");
        
        // Get the approvals table
        _approvealls approvals(get_self(), from.value);
        
        if(approved){
            // Set the approval for the NFT
            approvals.set(to, get_self());
        } else {
            // Remove the approval for the NFT
            approvals.remove();
        }
    }
```

### ìŠ¹ì¸ë°›ê¸°

ê·¸ë§Œí¼ `getapproved` ì‘ì—…ì€ ì „ì†¡í•˜ë„ë¡ ìŠ¹ì¸ëœ ê³„ì •ì„ ê°€ì ¸ì˜¤ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
ê·€í•˜ë¥¼ ëŒ€ì‹ í•˜ì—¬ NFT.

```cpp
    [[eosio::action]] name getapproved(uint64_t token_id){
        return get_approved(token_id);
    }
```

### ìŠ¹ì¸ë¨4ëª¨ë‘

ê·¸ë§Œí¼ `approved4all` ì‘ì—…ì€ ê³„ì •ì´ ì´ì „í•˜ë„ë¡ ìŠ¹ì¸ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
ê·€í•˜ë¥¼ ëŒ€ì‹ í•˜ì—¬ ê·€í•˜ì˜ ëª¨ë“  NFT.

```cpp
    [[eosio::action]] bool approved4all(name owner, name approved_account){
      return get_approved_all(owner) == approved_account;
   }
```

> âš  **ACTION ì´ë¦„ ì œí•œ**
>
> ê³„ì • ì´ë¦„ë„ í…Œì´ë¸” ì´ë¦„ê³¼ ë™ì¼í•œ ì œí•œì´ ìˆìœ¼ë¯€ë¡œ ë‹¤ìŒì„ í¬í•¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> ìºë¦­í„° `a-z`, `1-5`, ê·¸ë¦¬ê³  `.`. ì´ ë•Œë¬¸ì— í‘œì¤€ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. `isApprovedForAll`
> ì‘ì—…ì˜ ì´ë¦„ì´ë¯€ë¡œ ì‚¬ìš©í•˜ê³  ìˆìŠµë‹ˆë‹¤. `approved4all` ëŒ€ì‹ ì—.

### í† í°URI

ê·¸ë§Œí¼ `tokenuri` actionì€ NFTì˜ URIë¥¼ ê°€ì ¸ì˜¤ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

```cpp
    [[eosio::action]] std::string tokenuri(uint64_t token_id){
        return get_token_uri(token_id);
    }
```

### SetBaseURI

ê·¸ë§Œí¼ `setbaseuri` actionì€ NFTì˜ ê¸°ë³¸ URIë¥¼ ì„¤ì •í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

```cpp
    ACTION setbaseuri(std::string base_uri){
        // The account calling this action must be the contract owner
        require_auth(get_self());
        
        // Get the base URI table
        _base_uris base_uris(get_self(), get_self().value);
        
        // Set the base URI
        base_uris.set(base_uri, get_self());
    }
```



## í•¨ê»˜ ëª¨ì•„ì„œ

ì´ì œ ëª¨ë“  ì‘ì—…ì„ ë°°ì¹˜í–ˆìœ¼ë¯€ë¡œ ëª¨ë“  ì‘ì—…ì„ `nft.cpp` íŒŒì¼.

ì•„ë˜ì˜ ì „ì²´ ê³„ì•½ì„ ì‚´í´ë³´ê¸° ì „ì— ì§ì ‘ ê³„ì•½ì„ êµ¬ì¶•, ë°°í¬ ë° ìƒí˜¸ ì‘ìš©í•´ì•¼ í•©ë‹ˆë‹¤.
ë¨¼ì € ê·€í•˜ê°€ ê´€ë¦¬í•˜ëŠ” ê³„ì •ì— ì¼ë¶€ NFTë¥¼ ìƒì„±í•´ì•¼ í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ ë‹¤ë¥¸ ê³„ì •ìœ¼ë¡œ ì „ì†¡í•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ê·€í•˜ë¥¼ ëŒ€ì‹ í•˜ì—¬ NFTë¥¼ ì „ì†¡í•˜ë„ë¡ ë‹¤ë¥¸ ê³„ì •ì„ ìŠ¹ì¸í•˜ì—¬ ìŠ¹ì¸ ë©”ì»¤ë‹ˆì¦˜ì„ í…ŒìŠ¤íŠ¸í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
ê·¸ëŸ° ë‹¤ìŒ ìŠ¹ì¸ëœ ê³„ì •ì„ ì‚¬ìš©í•˜ì—¬ ë‹¤ë¥¸ ê³„ì •ìœ¼ë¡œ ì´ì²´í•©ë‹ˆë‹¤.

<ìƒì„¸>
    <summary>ì „ì²´ ê³„ì•½ì„ ë³´ë ¤ë©´ ì—¬ê¸°ë¥¼ í´ë¦­í•˜ì‹­ì‹œì˜¤.</summary>

```cpp
#include <eosio/eosio.hpp>
#include <eosio/asset.hpp>
#include <eosio/singleton.hpp>
using namespace eosio;

CONTRACT nft : public contract {

   public:
   using contract::contract;

   // Mapping from token ID to owner
   using _owners = singleton<"owners"_n, name>;
   
   // Mapping owner address to token count
   using _balances = singleton<"balances"_n, uint64_t>;
   
   // Mapping from token ID to approved address
   using _approvals = singleton<"approvals"_n, name>;
   
   // Mapping from owner to operator approvals
   using _approvealls = singleton<"approvealls"_n, name>;
   
   // Registering the token URI
   using _base_uris = singleton<"baseuris"_n, std::string>;

   // Helper function to get the owner of an NFT
   name get_owner(uint64_t token_id){
      _owners owners(get_self(), token_id);
      return owners.get_or_default(name(""));
   }
   
   // Helper function to get the balance of an account
   uint64_t get_balance(name owner){
      _balances balances(get_self(), owner.value);
      return balances.get_or_default(0);
   }
   
   // Helper function to get the account that is approved to transfer an NFT on your behalf
   name get_approved(uint64_t token_id){
      _approvals approvals(get_self(), token_id);
      return approvals.get_or_default(name(""));
   }
   
   // Helper function to get the account that is approved to transfer all of your NFTs on your behalf
   name get_approved_all(name owner){
      _approvealls approvals(get_self(), owner.value);
      return approvals.get_or_default(name(""));
   }
   
   // Helper function to get the URI of the NFT's metadata
   std::string get_token_uri(uint64_t token_id){
      _base_uris base_uris(get_self(), get_self().value);
      return base_uris.get_or_default("") + "/" + std::to_string(token_id);
   }
   
   ACTION mint(name to, uint64_t token_id){
      // We only want to mint NFTs if the action is called by the contract owner
      check(has_auth(get_self()), "only contract can mint");

      // The account we are minting to must exist
      check(is_account(to), "to account does not exist");

      // Get the owner singleton
      _owners owners(get_self(), token_id);

      // Check if the NFT already exists
      check(owners.get_or_default().value == 0, "NFT already exists");

      // Set the owner of the NFT to the account that called the action
      owners.set(to, get_self());

      // Get the balances table
      _balances balances(get_self(), to.value);

      // Set the new balances of the account
      balances.set(balances.get_or_default(0) + 1, get_self());
   }
   
   ACTION transfer(name from, name to, uint64_t token_id, std::string memo){
      // The account we are transferring from must authorize this action
      check(has_auth(from), "from account has not authorized the transfer");

      // The account we are transferring to must exist
      check(is_account(to), "to account does not exist");

      // The account we are transferring from must be the owner of the NFT
      // or allowed to transfer it through an approval
      bool ownerIsFrom = get_owner(token_id) == from;
      bool fromIsApproved = get_approved(token_id) == from;
      check(ownerIsFrom || fromIsApproved, "from account is not the owner of the NFT or approved to transfer the NFT");       

      // Get the owner singleton
      _owners owners(get_self(), token_id);

      // Set the owner of the NFT to the "to" account
      owners.set(to, get_self());

      // Set the new balance for the "from" account
      _balances balances(get_self(), from.value);
      balances.set(balances.get_or_default(0) - 1, get_self());

      // Set the new balance for the "to" account
      _balances balances2(get_self(), to.value);
      balances2.set(balances2.get_or_default(0) + 1, get_self());

      // Remove the approval for the "from" account
      _approvals approvals(get_self(), token_id);
      approvals.remove();

      // Send the transfer notification
      require_recipient(from);
      require_recipient(to);
   }
   
   [[eosio::action]] uint64_t balanceof(name owner){
      return get_balance(owner);
   }
   
   [[eosio::action]] name ownerof(uint64_t token_id){
      return get_owner(token_id);
   }
   
   ACTION approve(name to, uint64_t token_id){
      // get the token owner
      name owner = get_owner(token_id);
      
      // The owner of the NFT must authorize this action
      check(has_auth(owner), "owner has not authorized the approval");
   
      // The account we are approving must exist
      check(is_account(to), "to account does not exist");
      
      // Get the approvals table
      _approvals approvals(get_self(), token_id);
      
      // Set the approval for the NFT
      approvals.set(to, get_self());
   }
   
   ACTION approveall(name from, name to, bool approved){
      // The owner of the NFTs must authorize this action
      check(has_auth(from), "owner has not authorized the approval");
      
      // The account we are approving must exist
      check(is_account(to), "to account does not exist");
      
      // Get the approvals table
      _approvealls approvals(get_self(), from.value);
      
      if(approved){
         // Set the approval for the NFT
         approvals.set(to, get_self());
      } else {
         // Remove the approval for the NFT
         approvals.remove();
      }
   }
   
   [[eosio::action]] name getapproved(uint64_t token_id){
      return get_approved(token_id);
   }
   
   [[eosio::action]] bool approved4all(name owner, name approved_account){
      return get_approved_all(owner) == approved_account;
   }
   
   [[eosio::action]] std::string gettokenuri(uint64_t token_id){
      return get_token_uri(token_id);
   }
   
   ACTION setbaseuri(std::string base_uri){
      // The account calling this action must be the contract owner
      require_auth(get_self());
      
      // Get the base URI table
      _base_uris base_uris(get_self(), get_self().value);
      
      // Set the base URI
      base_uris.set(base_uri, get_self());
   }
};
```
</ì„¸ë¶€ ì‚¬í•­>

## êµìœ¡ìš©ì…ë‹ˆë‹¤.

ì´ ì»¨íŠ¸ë™íŠ¸ë¥¼ EOS ë„¤íŠ¸ì›Œí¬ì— ë°°í¬í•˜ê³  í† í°ì„ ë°œí–‰í•˜ë©´
íŒë§¤í•  ìˆ˜ ìˆëŠ” ì§€ì›ë˜ëŠ” ë§ˆì¼“í”Œë ˆì´ìŠ¤ê°€ ì—†ì„ ê²ƒì…ë‹ˆë‹¤(ì´ ê°€ì´ë“œë¥¼ ì‘ì„±í•  ë‹¹ì‹œ). ì´ëŠ” êµìœ¡ ëª©ì ì¼ ë¿ì…ë‹ˆë‹¤.

## ë„ì „

ì´ NFT ê³„ì•½ì—ëŠ” NFTë¥¼ ì†Œê°í•  ë°©ë²•ì´ ì—†ìŠµë‹ˆë‹¤. ì„ ì¶”ê°€í•˜ë‹¤ `burn` í† í° ì†Œìœ ìê°€ ìì‹ ì˜ NFTë¥¼ ì†Œê°í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì¡°ì¹˜ì…ë‹ˆë‹¤.
